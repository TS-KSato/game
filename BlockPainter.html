<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8">
  <title>Block Painter</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no, viewport-fit=cover">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Orbitron:wght@700;900&family=Roboto+Mono:wght@400;700&display=swap" rel="stylesheet">
  <style>
    :root {
      --main-bg: #181824;
      --glass-bg: rgba(35,35,56,0.85);
      --neon: #00FFD0;
      --neon2: #FF2080;
      --neutral: #232338;
      --white: #FFFFFF;
      --shadow: #0CFDFF44;
    }
    html, body {
      margin:0; padding:0; width:100vw; height:100vh; overflow:hidden; background: var(--main-bg);
    }
    body {
      min-height: 100vh;
      font-family:'Roboto Mono', 'Segoe UI', Verdana, Arial, 'ヒラギノ角ゴ ProN', sans-serif;
      display:flex; flex-direction:column; align-items:center; justify-content:center;
      color: var(--white);
      font-size: clamp(16px, 5vw, 20px);
      line-height: 1.45;
      letter-spacing: 0.03em;
      background: var(--main-bg);
    }
    #bg-glitch {
      z-index:0; position:fixed; top:0; left:0; width:100vw; height:100vh; pointer-events:none;
      background:
        repeating-linear-gradient(135deg, #18182C 0 3px, transparent 3px 14px),
        repeating-linear-gradient(-45deg, #232338 0 2px, transparent 2px 18px),
        linear-gradient(120deg, #1d192b 65%, #00FFD0 120%);
      opacity:0.65;
      animation:bgGlitch 4s infinite linear alternate;
      filter: blur(1.5px) brightness(1.10) contrast(1.05);
    }
    @keyframes bgGlitch {
      0% { background-position: 0 0,0 0,0 0;}
      25% { background-position: 8px 4px, -15px 18px, 0 20px;}
      50% { background-position: -6px -8px, 10px 22px, 0 -10px;}
      100% { background-position: 0 0,0 0,0 0;}
    }
    #gamebox {
      margin: 0 auto;
      max-width: 540px;
      width: 100vw;
      background: rgba(35,35,56,0.90);
      border-radius: 20px;
      box-shadow: 0 2px 24px var(--shadow);
      padding: 16px 0 24px 0;
      position:relative;
      z-index:1;
      display: flex; flex-direction: column; align-items: center;
      backdrop-filter: blur(2.8px) brightness(1.04);
    }
    #ui {
      width:96vw; max-width:96vw;
      display:flex;justify-content:space-between;align-items:center;
      gap: 14px;
      margin:16px 0 0 0; font-size:18px; user-select:none;
    }
    .hud {
      font-family: 'Orbitron', sans-serif;
      font-size: 17px;
      font-weight: bold;
      letter-spacing: 1.5px;
      display: flex;
      align-items: center;
      min-width: 60px;
      padding: 0 6px;
    }
    .hud-player { color: var(--neon); }
    .hud-cpu { color: var(--neon2); flex-direction: row-reverse; }
    .arrow { font-size: 1.3em; margin:0 5px; }
    .glass-card {
      background: var(--glass-bg);
      border: 1.5px solid var(--neon);
      border-radius: 12px;
      box-shadow: 0 2px 10px var(--shadow);
      padding: 10px 18px;
      min-width: 56px;
      text-align: center;
      font-weight: 600;
      color: var(--white);
      font-family: 'Orbitron', 'Roboto Mono', monospace;
      letter-spacing: 1.5px;
      font-size: 18px;
      transition: box-shadow 0.22s, background 0.15s;
      position:relative;
      overflow:hidden;
    }
    #timer { background: linear-gradient(90deg, var(--main-bg) 40%, var(--neon) 100%); border: 1.5px solid var(--neon); color: var(--white); font-size: 22px; box-shadow: 0 0 8px var(--shadow); }
    #game {
      width:96vw; height:96vw; max-width:96vw; max-height:72vw; outline:none;
      border-radius:3vw; touch-action:none;
      box-shadow: 0 0 44px var(--neon2), 0 0 8px var(--neon) inset;
      background:rgba(32,32,48,0.18);
      border:2px solid var(--neon);
      margin-top:10px;
      display:block;
    }
    .game-title, #start h1 {
      font-family: 'Orbitron', sans-serif;
      font-size: clamp(28px, 8vw, 36px);
      letter-spacing: -0.5px;
      color: var(--neon);
      text-shadow: 0 0 14px var(--neon), 0 1px 0 #232338;
      font-weight: 900;
      margin: 0 0 8px 0;
      text-align: center;
      text-transform: uppercase;
    }
    #start p {
      color: #c8fff6;
      background:rgba(0,255,208,0.11);
      padding:18px 14px;
      border-radius:10px;
      font-size:18px;
      margin-bottom:32px;
      line-height:1.6;
      text-shadow:0 0 8px #00FFD033;
      box-shadow:0 0 10px var(--neon2);
      text-align:center;
      font-family: 'Roboto Mono', monospace;
    }
    .cpk-btn, .game-btn {
      background: linear-gradient(90deg, var(--neon), var(--neon2) 100%);
      color: var(--main-bg);
      font-family: 'Orbitron', sans-serif;
      font-size: 20px;
      text-transform: uppercase;
      letter-spacing: 2px;
      border-radius: 16px;
      border: none;
      padding: 14px 0;
      margin: 12px 0 0 0;
      min-width: 70vw;
      min-height: 48px;
      font-weight: 800;
      box-shadow: 0 4px 24px var(--shadow);
      outline: 2px solid #00FFD088;
      position: relative;
      overflow: hidden;
      transition: transform 0.15s, box-shadow 0.18s, background 0.2s;
      cursor: pointer;
      display: block;
      text-align: center;
      outline-offset:2px;
    }
    .cpk-btn:active, .game-btn:active,
    .cpk-btn:focus, .game-btn:focus {
      transform: scale(0.97);
      box-shadow: 0 2px 12px #FF208088;
      background: linear-gradient(90deg, var(--neon2), var(--neon) 100%);
      outline: 2.5px solid var(--neon2);
    }
    #result, #start, #countdown {
      position:absolute;left:0;top:0;width:100%;height:100%;
      display:flex;flex-direction:column;align-items:center;justify-content:center;
      z-index:10;
      background:rgba(18,18,36,0.96);
      backdrop-filter:blur(8px) brightness(1.15);
      border-radius:22px;
      box-shadow:0 0 32px var(--shadow);
      padding:32px 12px 20px 12px;
      max-width:400px;
      margin:auto;
      color: var(--white);
      animation:fadeIn 0.7s;
      transition:opacity 0.3s;
    }
    @keyframes fadeIn { from { opacity:0;} to {opacity:1;} }
    #result{display:none;}
    #winner { color: var(--neon); font-size: 32px; margin-bottom: 8px; font-family:'Orbitron',sans-serif; letter-spacing:0.08em; text-shadow:0 3px 18px var(--neon),0 1px 2px #232338; text-align:center; font-weight:900; }
    #reason{ color: var(--neon2); font-size:20px; margin-bottom: 16px; text-align:center; font-family:'Roboto Mono',monospace; text-shadow: 0 1px 6px var(--neon2), 0 0 2px var(--white);}
    #countdown { font-family: 'Orbitron', sans-serif; color: var(--neon); font-size: 54px; letter-spacing:0.05em; text-shadow:0 0 24px var(--neon2),0 0 8px var(--neon); display:flex;align-items:center;justify-content:center; flex-direction:column; opacity:1; animation:countPulse 0.8s infinite alternate; }
    @keyframes countPulse {0%{text-shadow:0 0 8px var(--neon2);}100%{text-shadow:0 0 36px var(--neon);}}
    #countdown-label { font-size: 22px; margin-bottom: 10px; color: var(--white); text-shadow: 0 0 7px var(--neon2); letter-spacing:0.09em; font-family:'Roboto Mono',monospace; }
    #orientationWarning {
      display:none; position:fixed;top:0;left:0;width:100vw;height:100vh;
      background: var(--neon);
      color: var(--main-bg);
      z-index:10000;
      flex-direction:column;justify-content:center;align-items:center;text-align:center;
      font-size: 22px;
      font-family:'Orbitron',sans-serif;
      font-weight:bold;
      letter-spacing:2px;
      box-shadow: 0 2px 16px var(--shadow);
    }
    @media (max-width: 414px) {
      #gamebox { padding:8px 0 16px 0; }
      .cpk-btn, .game-btn { font-size: 18px; min-height: 52px; }
      .glass-card { font-size: 17px; padding: 8px 14px; }
      #timer { font-size: 18px; }
      #start h1, .game-title { font-size: 28px; }
    }
    @media (orientation: landscape){
      #game { height:60vw; }
      #ui { font-size: 14px; }
      .glass-card, #timer { font-size: 14px; }
      #start h1, .game-title { font-size: 22px; }
      #start p { font-size: 15px; }
      .cpk-btn { font-size: 15px; padding: 10px 0; }
      #orientationWarning{ font-size: 18px;}
      #countdown{ font-size: 32px;}
    }
  </style>
</head>
<body>
  <div id="bg-glitch"></div>
  <div id="gamebox">
    <div id="ui">
      <div class="hud hud-player"><span class="arrow">&#x25BC;</span>あなた</div>
      <div id="timer" class="glass-card">30</div>
      <div class="hud hud-cpu">CPU<span class="arrow">&#x25B2;</span></div>
    </div>
    <canvas id="game" width="800" height="800" tabindex="0"></canvas>
    <div id="result" role="dialog" aria-modal="true">
      <div id="winner"></div>
      <div id="reason"></div>
      <button class="cpk-btn game-btn" onclick="location.reload()">もう一度遊ぶ</button>
    </div>
    <div id="start" role="dialog" aria-modal="true">
      <h1 class="game-title">Block Painter</h1>
      <p>あなたは下側（<span style="color:#00FFD0">シアン</span>）、CPUは上側（<span style="color:#FF2080">ピンク</span>）です。中央から上下でエリア分割されています。相手または中立色のブロックのみヒット可能です。</p>
      <button class="cpk-btn game-btn" id="playbtn" role="button" aria-pressed="false">はじめる</button>
    </div>
    <div id="countdown" style="display:none;">
      <span id="countdown-label">ゲーム開始まで</span>
      <span id="count-number">3</span>
    </div>
  </div>
  <div id="orientationWarning">縦画面でご利用ください</div>
  <audio id="hit" src="https://cdn.jsdelivr.net/gh/thisable/audio@main/pop.mp3" preload="auto"></audio>
  <audio id="paint" src="https://cdn.jsdelivr.net/gh/thisable/audio@main/ping.mp3" preload="auto"></audio>
  <audio id="win" src="https://cdn.jsdelivr.net/gh/thisable/audio@main/win.mp3" preload="auto"></audio>
  <audio id="startSE" src="https://cdn.jsdelivr.net/gh/thisable/audio@main/startbeep.mp3" preload="auto"></audio>
  <script>
    const GRID = 16, BLOCKS = GRID * GRID,
      BLOCK_P = "#00FFD0",
      BLOCK_C = "#FF2080",
      BLOCK_N = "#232338",
      PADDLE_P = "#FFFFFF",
      PADDLE_C = "#FFFFFF",
      BALL_P = "#FFFFFF",
      BALL_C = "#FFFFFF",
      BG = "#181824";
    const PADDLE_WIDTH = 1.8, BALL_R = 0.18, MATCH = 30, FPS = 60;
    class Block {
      constructor(x, y) {
        this.x = x;
        this.y = y;
        this.type = "Normal";
        this.score = 1;
        this.hits = 0;
        this.maxHits = 1;
        this.owner = y < GRID / 2 ? 1 : 0;
      }
      hit(pid) {
        if (this.owner === pid) return { action: "none" };
        const prev = this.owner;
        this.owner = pid;
        return { action: "paint", prevOwner: prev, score: this.score };
      }
      color() {
        if (this.owner === 0) return BLOCK_P;
        if (this.owner === 1) return BLOCK_C;
        return BLOCK_N;
      }
    }
    class Paddle {
      constructor(y, color) { this.x = GRID / 2; this.y = y; this.color = color; this.w = PADDLE_WIDTH; }
      moveTo(nx) { this.x = Math.max(this.w / 2, Math.min(GRID - this.w / 2, nx)); }
    }
    class Ball {
      constructor(pid, color, startY) { this.pid = pid; this.x = GRID / 2; this.y = startY; this.r = BALL_R; this.color = color; this.reset(); }
      reset() {
        this.x = GRID / 2; this.y = this.pid ? 1.3 : GRID - 1.3;
        this.vx = (Math.random() - 0.5) * 0.045;
        this.vy = this.pid ? -0.10 : 0.10;
      }
      move() { this.x += this.vx; this.y += this.vy; }
    }
    class Game {
      constructor() {
        this.canvas = document.getElementById('game');
        this.ctx = this.canvas.getContext('2d');
        this.blocks = [];
        this.paddles = [null, null];
        this.balls = [null, null];
        this.score = [0, 0];
        this.timer = MATCH;
        this.state = "wait";
        this.touchId = null;
        this.waitingForStart = true;
        this.init();
        this.resize();
        this.setupInput();
        this.loopBind = this.loop.bind(this);
      }
      init() {
        this.blocks = [];
        for (let y = 0; y < GRID; y++) for (let x = 0; x < GRID; x++) this.blocks.push(new Block(x, y));
        this.paddles[0] = new Paddle(GRID - 0.5, PADDLE_P);
        this.paddles[1] = new Paddle(0.5, PADDLE_C);
        this.balls[0] = new Ball(0, BALL_P, GRID - 1.3);
        this.balls[1] = new Ball(1, BALL_C, 1.3);
        this.score = [0, 0];
        this.timer = MATCH;
        this.state = "wait";
        this.waitingForStart = true;
        document.getElementById("timer").textContent = MATCH;
      }
      setupInput() {
        let self = this, canvas = this.canvas;
        canvas.addEventListener("pointerdown", e => {
          if (self.state !== "playing") return; self.handlePointer(e); self.touchId = e.pointerId; canvas.setPointerCapture(e.pointerId);
        });
        canvas.addEventListener("pointermove", e => { if (self.state !== "playing" || e.pointerId !== self.touchId) return; self.handlePointer(e); });
        canvas.addEventListener("pointerup", e => { if (e.pointerId === self.touchId) { self.touchId = null; canvas.releasePointerCapture(e.pointerId); } });
        canvas.addEventListener("pointerleave", e => { if (e.pointerId === self.touchId) { self.touchId = null; canvas.releasePointerCapture(e.pointerId); } });
        window.addEventListener("keydown", e => {
          if (self.state !== "playing") return;
          if (e.key === "ArrowLeft") { self.paddles[0].moveTo(self.paddles[0].x - 0.65); }
          if (e.key === "ArrowRight") { self.paddles[0].moveTo(self.paddles[0].x + 0.65); }
        });
        window.addEventListener("resize", () => { self.resize(); enforcePortrait(); });
      }
      handlePointer(e) {
        const rect = this.canvas.getBoundingClientRect(), x = e.clientX - rect.left;
        const nx = GRID * x / this.canvas.width;
        this.paddles[0].moveTo(nx);
      }
      resize() {
        const s = Math.min(window.innerWidth * 0.96, window.innerHeight * 0.72, 540);
        this.canvas.width = this.canvas.height = s;
      }
      start() {
        if (!this.waitingForStart) return;
        this.state = "playing"; this.waitingForStart = false;
        requestAnimationFrame(this.loopBind);
      }
      loop() {
        if (this.state !== "playing") return;
        this.timer -= 1 / FPS; if (this.timer <= 0) { this.finish("時間切れ"); return; }
        document.getElementById("timer").textContent = String(Math.ceil(this.timer));
        let cpuPaddle = this.paddles[1], cpuBall = this.balls[1];
        let targetX = cpuBall.y < GRID / 2 ? cpuBall.x : GRID / 2;
        cpuPaddle.moveTo(cpuPaddle.x + (targetX - cpuPaddle.x) * 0.12);
        for (let pid = 0; pid < 2; pid++) {
          let b = this.balls[pid], p = this.paddles[pid];
          b.move();
          if (Math.abs(b.x - p.x) < p.w / 2 && Math.abs(b.y - p.y) < 0.44 && ((pid === 0 && b.vy > 0) || (pid === 1 && b.vy < 0))) {
            b.vy *= -1; b.vx += (b.x - p.x) * 0.09; b.vx = Math.max(-0.17, Math.min(0.17, b.vx)); b.y = pid === 0 ? p.y - 0.45 : p.y + 0.45; this.se("hit");
          }
          if (b.x - b.r < 0) { b.x = b.r; b.vx *= -1; this.se("hit"); }
          if (b.x + b.r > GRID) { b.x = GRID - b.r; b.vx *= -1; this.se("hit"); }
          if (pid === 0 && (b.y > GRID - 0.1)) { this.finish("あなたがミスして終了"); return; }
          if (pid === 1 && (b.y < 0.1)) { this.finish("CPUがミスしてあなたの勝ち！"); return; }
          for (let bl of this.blocks) {
            if (b.x + b.r > bl.x && b.x - b.r < bl.x + 1 && b.y + b.r > bl.y && b.y - b.r < bl.y + 1) {
              if (bl.owner === pid) continue;
              const hitOutcome = bl.hit(pid);
              if (hitOutcome.action === "paint") {
                if (hitOutcome.prevOwner !== -1 && hitOutcome.prevOwner !== pid) this.score[hitOutcome.prevOwner] = Math.max(0, this.score[hitOutcome.prevOwner] - bl.score);
                this.score[pid] += bl.score; this.se("paint"); b.vy *= -1; break;
              }
            }
          }
        }
        this.render();
        requestAnimationFrame(this.loopBind);
      }
      se(name) {
        let a = document.getElementById(name);
        if (a) { a.currentTime = 0; a.play().catch(() => {});}
      }
      finish(reason) {
        this.state = "result";
        let winnerText, reasonText = reason || "";
        if (reason && reason.includes("CPUがミス")) { winnerText = "あなたの勝ち！";
        } else if (reason && reason.includes("あなたがミス")) { winnerText = "CPUの勝ち";
        } else {
          let pscore = 0, cscore = 0;
          for (let bl of this.blocks) {
            if (bl.owner === 0) pscore++;
            else if (bl.owner === 1) cscore++;
          }
          winnerText = pscore > cscore ? "あなたの勝ち！" : (pscore < cscore ? "CPUの勝ち" : "引き分け！");
        }
        document.getElementById("result").style.display = "flex";
        document.getElementById("winner").textContent = winnerText;
        document.getElementById("reason").textContent = reasonText;
        this.se("win");
      }
      render() {
        const ctx = this.ctx, s = this.canvas.width / GRID;
        ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
        ctx.fillStyle = BG;
        ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);
        for (let bl of this.blocks) {
          ctx.save();
          ctx.globalAlpha = 1;
          ctx.fillStyle = bl.color();
          if (bl.y === GRID / 2 - 1 || bl.y === GRID / 2) {
            ctx.strokeStyle = "#FFF";
            ctx.lineWidth = 4;
          } else {
            ctx.strokeStyle = "#444";
            ctx.lineWidth = 1.2;
          }
          ctx.beginPath();
          ctx.rect((bl.x + 0.03) * s, (bl.y + 0.03) * s, s * 0.93, s * 0.93);
          ctx.fill();
          ctx.stroke();
          ctx.restore();
        }
        for (let pid = 0; pid < 2; pid++) {
          let p = this.paddles[pid];
          ctx.save();
          ctx.fillStyle = "#FFFFFF";
          ctx.shadowColor = pid ? "#FF2080" : "#00FFD0";
          ctx.shadowBlur = 16;
          ctx.beginPath();
          ctx.roundRect((p.x - PADDLE_WIDTH / 2) * s, (p.y - 0.18) * s, s * PADDLE_WIDTH, s * 0.44, s * 0.21);
          ctx.fill();
          ctx.restore();
        }
        for (let pid = 0; pid < 2; pid++) {
          let b = this.balls[pid];
          ctx.save();
          ctx.beginPath();
          ctx.arc(b.x * s, b.y * s, s * BALL_R, 0, 2 * Math.PI);
          ctx.fillStyle = "#FFFFFF";
          ctx.shadowColor = pid ? "#FF2080" : "#00FFD0";
          ctx.shadowBlur = 24;
          ctx.globalAlpha = 0.97;
          ctx.fill();
          ctx.restore();
        }
        let pscore = 0, cscore = 0;
        for (let bl of this.blocks) {
          if (bl.owner === 0) pscore++;
          else if (bl.owner === 1) cscore++;
        }
        document.querySelector(".hud-player").textContent = `あなた: ${pscore}`;
        document.querySelector(".hud-cpu").textContent = `CPU: ${cscore}`;
        document.querySelector(".hud-player").insertAdjacentHTML('afterbegin','<span class="arrow">&#x25BC;</span>');
        document.querySelector(".hud-cpu").insertAdjacentHTML('beforeend','<span class="arrow">&#x25B2;</span>');
      }
    }
    let g;
    function startCountdownThenPlay() {
      const cd = document.getElementById("countdown");
      const start = document.getElementById("start");
      const result = document.getElementById("result");
      start.style.display = "none"; result.style.display = "none";
      cd.style.display = "flex";
      let count = 3;
      const countNum = document.getElementById("count-number");
      countNum.textContent = count;
      let countdownSE = () => {
        let a = document.getElementById("startSE");
        if(a){a.currentTime=0;a.play().catch(()=>{});}
      }
      countdownSE();
      let interval = setInterval(() => {
        count--;
        if(count>0){
          countNum.textContent = count;
          countdownSE();
        }else if(count===0){
          countNum.textContent = "START!";
          countdownSE();
        }else{
          clearInterval(interval);
          cd.style.display = "none";
          g = new Game();
          setTimeout(()=>g.start(), 120);
        }
      }, 800);
    }
    document.getElementById("playbtn").onclick = startCountdownThenPlay;
    function enforcePortrait() {
      const w = document.getElementById('orientationWarning');
      if (w) {
        if (window.innerWidth > window.innerHeight && window.matchMedia("(orientation: landscape)").matches) {
          w.style.display = 'flex';
        } else {
          w.style.display = 'none';
        }
      }
    }
    window.addEventListener("resize", enforcePortrait);
    document.addEventListener("DOMContentLoaded", enforcePortrait);
  </script>
</body>
</html>
