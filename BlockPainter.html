<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8">
  <title>Block Painter</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no, viewport-fit=cover">
  <link href="https://fonts.googleapis.com/css2?family=Orbitron:wght@700;900&family=Roboto+Mono:wght@400;700&display=swap" rel="stylesheet">
  <style>
    html, body {height: 100dvh;width: 100dvw;margin: 0;padding: 0;background: #181824;overflow: hidden;box-sizing: border-box;padding-top: env(safe-area-inset-top, 0px);padding-bottom: env(safe-area-inset-bottom, 0px);padding-left: env(safe-area-inset-left, 0px);padding-right: env(safe-area-inset-right, 0px);overscroll-behavior: none;touch-action: none;}
    body {min-height: 100dvh;min-width: 100dvw;display: flex;align-items: center;justify-content: center;font-family: 'Roboto Mono', 'Segoe UI', Verdana, Arial, 'ヒラギノ角ゴ ProN', sans-serif;color: #FFF;font-size: clamp(16px, 5vw, 20px);background: #181824;}
    #gamebox {width: min(96vw, 96vh, 520px);height: min(96vw, 96vh, 520px);max-width: 98vw;max-height: 98vh;margin: auto;background: rgba(35, 35, 56, 0.98);border-radius: 18px;box-shadow: 0 2px 16px #0CFDFF44;padding: 10px 0 20px 0;display: flex;flex-direction: column;align-items: center;justify-content: center;position: relative;}
    #ui {width: 90%;max-width: 96vw;display: flex;justify-content: space-between;align-items: center;gap: 14px;margin: 8px 0 0 0;font-size: 18px;user-select: none;}
    .hud {font-family: 'Orbitron', sans-serif;font-size: 17px;font-weight: bold;letter-spacing: 1.5px;display: flex;align-items: center;min-width: 60px;padding: 0 6px;}
    .hud-player {color: #00FFD0;}
    .hud-cpu {color: #FF2080;flex-direction: row-reverse;}
    .arrow {font-size: 1.3em;margin: 0 5px;}
    #timer {background: linear-gradient(90deg, #181824 40%, #00FFD0 100%);border: 1.5px solid #00FFD0;border-radius: 12px;color: #fff;font-size: 20px;padding: 6px 18px;font-family: 'Orbitron', sans-serif;letter-spacing: 1.2px;box-shadow: 0 0 8px #0CFDFF44;text-align: center;min-width: 54px;}
    #game {width: 90%;height: 90%;max-width: 96vw;max-height: 78vw;aspect-ratio: 1 / 1;border-radius: 3vw;box-shadow: 0 0 28px #FF208055, 0 0 8px #00FFD0 inset;background: rgba(32, 32, 48, 0.18);border: 2px solid #00FFD0;margin-top: 10px;display: block;touch-action: none;outline: none;}
    .game-title,#start h1 {font-family: 'Orbitron', sans-serif;font-size: clamp(28px, 8vw, 36px);letter-spacing: -0.5px;color: #00FFD0;text-shadow: 0 0 14px #00FFD0, 0 1px 0 #232338;font-weight: 900;margin: 0 0 8px 0;text-align: center;text-transform: uppercase;}
    #start p {color: #c8fff6;background: rgba(0, 255, 208, 0.11);padding: 16px 12px;border-radius: 10px;font-size: 17px;margin-bottom: 22px;line-height: 1.5;box-shadow: 0 0 6px #FF208044;text-align: center;font-family: 'Roboto Mono', monospace;}
    .game-btn {background: linear-gradient(90deg, #00FFD0, #FF2080 100%);color: #181824;font-family: 'Orbitron', sans-serif;font-size: 20px;letter-spacing: 2px;border-radius: 16px;border: none;padding: 14px 0;margin: 14px 0 0 0;min-width: 72vw;min-height: 48px;font-weight: 800;box-shadow: 0 4px 20px #0CFDFF44;outline: 2px solid #00FFD044;position: relative;transition: transform 0.15s, box-shadow 0.18s, background 0.2s;cursor: pointer;display: block;text-align: center;outline-offset: 2px;}
    .game-btn:active,.game-btn:focus {transform: scale(0.97);box-shadow: 0 2px 12px #FF208088;background: linear-gradient(90deg, #FF2080, #00FFD0 100%);outline: 2.5px solid #FF2080;}
    #result,#start,#countdown {position: absolute;top: 50%;left: 50%;transform: translate(-50%, -50%);width: 90%;height: auto;max-width: 100%;max-height: 100%;display: flex;flex-direction: column;align-items: center;justify-content: center;z-index: 10;background: rgba(18, 18, 36, 0.96);backdrop-filter: blur(6px) brightness(1.12);border-radius: 18px;box-shadow: 0 0 24px #00FFD044;padding: 5vw 2vw 3vw 2vw;color: #fff;animation: fadeIn 0.7s;transition: opacity 0.3s;margin: 0;}
    #result {display: none;}
    @keyframes fadeIn {from {opacity: 0;}to {opacity: 1;}}
    #winner {color: #00FFD0;font-size: 29px;margin-bottom: 8px;font-family: 'Orbitron', sans-serif;letter-spacing: 0.08em;text-shadow: 0 2px 16px #00FFD0, 0 1px 2px #232338;text-align: center;font-weight: 900;}
    #reason {color: #FF2080;font-size: 18px;margin-bottom: 12px;text-align: center;font-family: 'Roboto Mono', monospace;text-shadow: 0 1px 6px #FF2080, 0 0 2px #fff;}
    #countdown {font-family: 'Orbitron', sans-serif;color: #00FFD0;font-size: 46px;letter-spacing: 0.05em;text-shadow: 0 0 18px #FF2080, 0 0 7px #00FFD0;display: flex;align-items: center;justify-content: center;flex-direction: column;opacity: 1;animation: countPulse 0.8s infinite alternate;}
    @keyframes countPulse {0% {text-shadow: 0 0 7px #FF2080;}100% {text-shadow: 0 0 26px #00FFD0;}}
    #countdown-label {font-size: 19px;margin-bottom: 10px;color: #fff;text-shadow: 0 0 5px #FF2080;}
    #orientationWarning {display: none;position: fixed;top: 0;left: 0;width: 100vw;height: 100dvh;background: #00FFD0;color: #181824;z-index: 10000;flex-direction: column;justify-content: center;align-items: center;text-align: center;font-size: 21px;font-family: 'Orbitron', sans-serif;font-weight: bold;letter-spacing: 2px;box-shadow: 0 2px 16px #00FFD044;}
    #virtualPad {position: fixed;left: 50%;bottom: 22px;transform: translateX(-50%);width: 118px;height: 118px;border-radius: 50%;background: linear-gradient(135deg, #00FFD0 40%, #FF2080 120%);box-shadow: 0 4px 24px #00FFD044;display: none;align-items: center;justify-content: center;z-index: 2000;user-select: none;touch-action: none;opacity: 0.93;pointer-events: auto;}
    #padInner {width: 58px;height: 58px;border-radius: 50%;background: #181824;box-shadow: 0 2px 18px #fff8, 0 0 0 4px #fff3 inset;transition: transform 0.09s, box-shadow 0.09s;will-change: transform;pointer-events: none;}
    #virtualPad:active #padInner,#virtualPad.active #padInner {background: #222248;box-shadow: 0 4px 28px #00ffd099, 0 0 0 8px #ff208022 inset;transform: scale(1.12);}
    @media (max-width: 414px) {#gamebox {padding: 8px 0 12px 0;}.game-btn {font-size: 17px;min-height: 48px;}#timer {font-size: 17px;}#start h1,.game-title {font-size: 25px;}#virtualPad {width: 80px;height: 80px;}#padInner {width: 33px;height: 33px;}}
    @media (orientation: landscape) {#gamebox {width: min(60vw, 60vh, 380px);height: min(60vw, 60vh, 380px);}#game {height: 60vw;}#ui {font-size: 14px;}#timer {font-size: 13px;}#start h1,.game-title {font-size: 18px;}.game-btn {font-size: 13px;padding: 8px 0;}#orientationWarning {font-size: 15px;}#countdown {font-size: 28px;}#virtualPad {width: 54px;height: 54px;}#padInner {width: 21px;height: 21px;}}
  </style>
</head>
<body>
  <div id="gamebox">
    <div id="ui">
      <!-- MODIFIED: Added spans for scores for easier JS targeting -->
      <div class="hud hud-player"><span class="arrow">▼</span>あなた: <span id="player-score">0</span></div>
      <div id="timer">30</div>
      <div class="hud hud-cpu">CPU: <span id="cpu-score">0</span><span class="arrow">▲</span></div>
    </div>
    <canvas id="game" width="800" height="800" tabindex="0"></canvas>
    <div id="result" role="dialog" aria-modal="true">
      <div id="winner"></div>
      <div id="reason"></div>
      <button class="game-btn" onclick="location.reload()">もう一度遊ぶ</button>
    </div>
    <div id="start" role="dialog" aria-modal="true">
      <h1 class="game-title">Block Painter</h1>
      <p>画面下の<b>大きな円形パッド</b>に指を置き、左右にスライドしてパドルを操作してください。ピンチズームやスワイプなど<br>他の操作はゲーム中無効です。</p>
      <button class="game-btn" id="playbtn" role="button" aria-pressed="false">はじめる</button>
    </div>
    <div id="countdown" style="display:none;">
      <span id="countdown-label">ゲーム開始まで</span>
      <span id="count-number">3</span>
    </div>
  </div>
  <div id="virtualPad" aria-label="バーチャルパッド" tabindex="0">
    <div id="padInner"></div>
  </div>
  <div id="orientationWarning">縦画面でご利用ください</div>
  <audio id="hit" src="https://cdn.jsdelivr.net/gh/thisable/audio@main/pop.mp3" preload="auto"></audio>
  <audio id="paint" src="https://cdn.jsdelivr.net/gh/thisable/audio@main/ping.mp3" preload="auto"></audio>
  <audio id="win" src="https://cdn.jsdelivr.net/gh/thisable/audio@main/win.mp3" preload="auto"></audio>
  <audio id="startSE" src="https://cdn.jsdelivr.net/gh/thisable/audio@main/startbeep.mp3" preload="auto"></audio>
  <script>
    // --- 変数・初期化 ---
    let isPlaying = false;
    // --- タッチ/ジェスチャ無効化 ---
    document.addEventListener('touchstart', function (e) {
      if (isPlaying && !e.target.closest("#virtualPad")) e.preventDefault();
    }, { passive: false });
    document.addEventListener('touchmove', function (e) {
      if (isPlaying && !e.target.closest("#virtualPad")) e.preventDefault();
    }, { passive: false });
    document.addEventListener('touchend', function (e) {
      if (isPlaying && !e.target.closest("#virtualPad")) e.preventDefault();
    }, { passive: false });
    document.addEventListener('gesturestart', e => { if (isPlaying) e.preventDefault(); });
    document.addEventListener('gesturechange', e => { if (isPlaying) e.preventDefault(); });
    document.addEventListener('gestureend', e => { if (isPlaying) e.preventDefault(); });

    // --- 画面縦固定 ---
    function enforcePortrait() {
      const w = document.getElementById('orientationWarning');
      if (w) {
        if (window.innerWidth > window.innerHeight && window.matchMedia("(orientation: landscape)").matches) {
          w.style.display = 'flex';
        } else {
          w.style.display = 'none';
        }
      }
    }
    window.addEventListener("resize", enforcePortrait);
    document.addEventListener("DOMContentLoaded", enforcePortrait);

    // --- 安全領域取得 ---
    function getSafeAreaInset(styleProp, fallback = 0) {
      const val = parseInt(getComputedStyle(document.documentElement).getPropertyValue(styleProp));
      return isNaN(val) ? fallback : val;
    }

    // --- 定数 ---
    const GRID = 12,
      BLOCK_P = "#00FFD0", BLOCK_C = "#FF2080", BLOCK_N = "#232338",
      PADDLE_P = "#FFFFFF", PADDLE_C = "#FFFFFF",
      BALL_P = "#FFFFFF", BALL_C = "#FFFFFF",
      BG = "#181824";
    const PADDLE_WIDTH = 1.8, BALL_R = 0.18, MATCH = 30, FPS = 60;
    const PADDLE_HALF_HEIGHT = 0.22; // Derived from roundRect height 0.44

    // --- ブロッククラス ---
    class Block {
      constructor(x, y) {
        this.x = x; this.y = y; this.type = "Normal";
        this.owner = y < GRID / 2 ? 1 : 0; // 0 for Player, 1 for CPU
      }
      hit(pid) {
        if (this.owner === pid) return { action: "none" };
        const prev = this.owner; this.owner = pid;
        return { action: "paint", prevOwner: prev };
      }
      color() {
        if (this.owner === 0) return BLOCK_P;
        if (this.owner === 1) return BLOCK_C;
        return BLOCK_N;
      }
    }
    // --- パドルクラス ---
    class Paddle {
      constructor(y, color) { this.x = GRID / 2; this.y = y; this.color = color; this.w = PADDLE_WIDTH; }
      moveTo(nx) { this.x = Math.max(this.w / 2, Math.min(GRID - this.w / 2, nx)); }
    }
    // --- ボールクラス ---
    class Ball {
      constructor(pid, color, startY) { this.pid = pid; this.x = GRID / 2; this.y = startY; this.r = BALL_R; this.color = color; this.reset(); }
      reset() {
        this.x = GRID / 2; this.y = this.pid ? 1.3 : GRID - 1.3; // CPU (1) starts top, Player (0) starts bottom
        this.vx = (Math.random() - 0.5) * 0.045;
        this.vy = this.pid ? 0.10 : -0.10; // CPU (1) moves down (+vy), Player (0) moves up (-vy)
      }
      move() { this.x += this.vx; this.y += this.vy; }
    }

    // --- ゲームクラス ---
    class Game {
      constructor() {
        this.canvas = document.getElementById('game');
        this.ctx = this.canvas.getContext('2d');
        this.blocks = [];
        this.paddles = [null, null];
        this.balls = [null, null];
        this.timer = MATCH;
        this.state = "wait";
        this.waitingForStart = true;
        this.cpuNoMissUntil = 20; // Seconds CPU plays perfectly
        
        // ADDED: Cache HUD elements
        this.playerScoreEl = document.getElementById("player-score");
        this.cpuScoreEl = document.getElementById("cpu-score");
        this.timerEl = document.getElementById("timer");

        this.init();
        this.resize();
        this.loopBind = this.loop.bind(this);
        this.cpuTargetX = null;
        this.cpuSkill = 1;
        this.cpuJitter = 0;
        this.lastBallDir = null; // For CPU AI
        window.addEventListener('resize', () => this.resize());
      }
      init() {
        this.blocks = [];
        for (let y = 0; y < GRID; y++) for (let x = 0; x < GRID; x++) this.blocks.push(new Block(x, y));
        this.paddles[0] = new Paddle(GRID - 0.5, PADDLE_P); // Player paddle
        this.paddles[1] = new Paddle(0.5, PADDLE_C);       // CPU paddle
        this.balls[0] = new Ball(0, BALL_P, GRID - 1.3);   // Player ball
        this.balls[1] = new Ball(1, BALL_C, 1.3);          // CPU ball
        this.timer = MATCH;
        this.state = "wait";
        this.waitingForStart = true;
        this.timerEl.textContent = MATCH;
        this.playerScoreEl.textContent = "0"; // ADDED: Initialize scores
        this.cpuScoreEl.textContent = "0";    // ADDED: Initialize scores
      }
      resize() {
        const safeTop = getSafeAreaInset('padding-top', 0);
        const safeBottom = getSafeAreaInset('padding-bottom', 0);
        const safeLeft = getSafeAreaInset('padding-left', 0);
        const safeRight = getSafeAreaInset('padding-right', 0);
        const safeW = window.innerWidth - safeLeft - safeRight;
        const safeH = window.innerHeight - safeTop - safeBottom;
        const s = Math.min(safeW * 0.96, safeH * 0.96, 520);
        this.canvas.width = this.canvas.height = s; // Use the calculated game box size for canvas
      }
      start() {
        if (!this.waitingForStart) return;
        this.state = "playing"; this.waitingForStart = false;
        isPlaying = true;
        document.getElementById("virtualPad").style.display = "flex";
        requestAnimationFrame(this.loopBind);
      }
      loop() {
        if (this.state !== "playing") return;
        this.timer -= 1 / FPS; if (this.timer <= 0) { this.finish("時間切れ"); return; }
        this.timerEl.textContent = String(Math.ceil(this.timer));

        // --- CPU AI ---
        let cpuPaddle = this.paddles[1], cpuBall = this.balls[1]; // CPU controls its own ball
        let playTime = MATCH - this.timer;

        // MODIFIED: CPU reacts when its ball (ball[1]) is coming TOWARDS it (vy < 0)
        if (cpuBall.vy < 0) { 
          let currentDir = Math.sign(cpuBall.vy); // Will be -1
          if (playTime < this.cpuNoMissUntil) { // Perfect play period
            let predictX = this.predictBallLandingX(cpuBall, cpuPaddle.y);
            cpuPaddle.moveTo(cpuPaddle.x + (predictX - cpuPaddle.x) * 0.7); // Faster tracking
          } else { // Imperfect play period
            if (this.lastBallDir !== currentDir || this.cpuTargetX === null) { // Re-target if direction changed or no target
              this.cpuSkill = 0.87 + Math.random() * 0.15; // Random skill factor
              this.cpuJitter = (Math.random() - 0.5) * 1.0; // Random jitter
              this.cpuTargetX = this.predictBallLandingX(cpuBall, cpuPaddle.y) * this.cpuSkill + this.cpuJitter;
              this.lastBallDir = currentDir;
            }
            cpuPaddle.moveTo(cpuPaddle.x + (this.cpuTargetX - cpuPaddle.x) * 0.13); // Slower tracking
          }
        } else { // Ball not coming towards CPU, or CPU is serving
          cpuPaddle.moveTo(cpuPaddle.x + ((GRID / 2) - cpuPaddle.x) * 0.08); // Move towards center slowly
        }


        // --- ゲーム進行: 物理処理 ---
        for (let pid = 0; pid < 2; pid++) {
          let b = this.balls[pid], p = this.paddles[pid];
          b.move();

          // 壁バウンド
          if (b.x - b.r < 0) { b.x = b.r; b.vx *= -1; }
          if (b.x + b.r > GRID) { b.x = GRID - b.r; b.vx *= -1; }

          // パドル衝突判定
          let paddleY = p.y;
          let towardPaddle = (pid === 0 && b.vy < 0) || (pid === 1 && b.vy > 0); // Player 0: vy<0 (up), CPU 1: vy>0 (down)
          let yDist = Math.abs(b.y - paddleY);
          let xDist = Math.abs(b.x - p.x);

          if (towardPaddle && yDist < (PADDLE_HALF_HEIGHT + b.r) && xDist < (p.w / 2 + b.r)) {
            b.vy *= -1;
            let offset = (b.x - p.x) / (p.w / 2);
            b.vx += offset * 0.04;
            b.vx = Math.max(-0.2, Math.min(0.2, b.vx));
            
            // MODIFIED: Correct Y-positioning after paddle hit
            const collisionOffset = PADDLE_HALF_HEIGHT + b.r + 0.01; // Small epsilon to prevent re-collision
            if (pid === 0) { // Player 0 (bottom paddle)
              b.y = p.y - collisionOffset; // Ball should be above the paddle center
            } else { // CPU 1 (top paddle)
              b.y = p.y + collisionOffset; // Ball should be below the paddle center
            }
            this.se("hit");
          }

          // ブロック衝突
          let hitBlock = null;
          for (const bl of this.blocks) {
            const blockCenterX = bl.x + 0.5;
            const blockCenterY = bl.y + 0.5;
            const distXb = Math.abs(b.x - blockCenterX); // Renamed to avoid conflict with outer scope distX
            const distYb = Math.abs(b.y - blockCenterY); // Renamed

            if (distXb > (0.5 + b.r) || distYb > (0.5 + b.r)) continue; // AABB check
            if (distXb <= 0.5 || distYb <= 0.5) { hitBlock = bl; break; } // Face hit
            const cornerDistSq = Math.pow(distXb - 0.5, 2) + Math.pow(distYb - 0.5, 2);
            if (cornerDistSq <= (b.r * b.r)) { hitBlock = bl; break; } // Corner hit
          }

          if (hitBlock) {
            let res = hitBlock.hit(pid);
            if (res.action === "paint") this.se("paint");

            let bx_rel = b.x - (hitBlock.x + 0.5);
            let by_rel = b.y - (hitBlock.y + 0.5);
            const overlapX = (0.5 + b.r) - Math.abs(bx_rel);
            const overlapY = (0.5 + b.r) - Math.abs(by_rel);

            // MODIFIED: Improved block collision response, especially for corners/ambiguous cases
            if (overlapY < overlapX && overlapY > 0.001) { // Hit top/bottom face primarily
              b.vy *= -1;
              b.y = (hitBlock.y + 0.5) + (by_rel > 0 ? (0.5 + b.r) : -(0.5 + b.r));
            } else if (overlapX < overlapY && overlapX > 0.001) { // Hit left/right face primarily
              b.vx *= -1;
              b.x = (hitBlock.x + 0.5) + (bx_rel > 0 ? (0.5 + b.r) : -(0.5 + b.r));
            } else { // Corner hit or ambiguous (overlaps are similar, or one is zero/negative)
              // Determine if it's more of a corner geometric situation
              const blockCenterX = hitBlock.x + 0.5;
              const blockCenterY = hitBlock.y + 0.5;
              const isCornerRegion = Math.abs(b.x - blockCenterX) > 0.5 && Math.abs(b.y - blockCenterY) > 0.5;

              if (isCornerRegion && overlapX > 0.001 && overlapY > 0.001) { // True corner hit with penetration on both axes
                b.vx *= -1;
                b.vy *= -1;
                // Reposition on both axes for corner
                b.x = (hitBlock.x + 0.5) + (bx_rel > 0 ? (0.5 + b.r) : -(0.5 + b.r));
                b.y = (hitBlock.y + 0.5) + (by_rel > 0 ? (0.5 + b.r) : -(0.5 + b.r));
              } else { // Fallback: reflect based on dominant relative position and reposition if overlap
                if (Math.abs(by_rel) >= Math.abs(bx_rel)) {
                  b.vy *= -1;
                  if (overlapY > 0.001) b.y = (hitBlock.y + 0.5) + (by_rel > 0 ? (0.5 + b.r) : -(0.5 + b.r));
                } else {
                  b.vx *= -1;
                  if (overlapX > 0.001) b.x = (hitBlock.x + 0.5) + (bx_rel > 0 ? (0.5 + b.r) : -(0.5 + b.r));
                }
              }
            }
          }


          // ゴール判定
          if (pid === 0 && b.y < -0.4) { this.finish("あなたがミスしました"); return; } // Player's ball goes off top
          if (pid === 1 && b.y > GRID + 0.4) { this.finish("CPUがミスしました"); return; } // CPU's ball goes off bottom
        }

        this.render();
        requestAnimationFrame(this.loopBind);
      }

      se(name) {
        let a = document.getElementById(name);
        if (a) { a.currentTime = 0; a.play().catch(() => { }); }
      }
      finish(reason) {
        this.state = "result";
        isPlaying = false;
        document.getElementById("virtualPad").style.display = "none";
        let winnerText, reasonText = reason || "";
        if (reason && reason.includes("CPUがミス")) {
          winnerText = "あなたの勝ち！";
        } else if (reason && reason.includes("あなたがミス")) {
          winnerText = "CPUの勝ち";
        } else { // Time up
          let pscore = 0, cscore = 0;
          for (let bl of this.blocks) {
            if (bl.owner === 0) pscore++;
            else if (bl.owner === 1) cscore++;
          }
          if (pscore > cscore) winnerText = "あなたの勝ち！";
          else if (pscore < cscore) winnerText = "CPUの勝ち";
          else winnerText = "引き分け！";
          reasonText = `時間切れ！ あなた: ${pscore} vs CPU: ${cscore}`; // ADDED: More informative reason for time up
        }
        document.getElementById("result").style.display = "flex";
        document.getElementById("winner").textContent = winnerText;
        document.getElementById("reason").textContent = reasonText;
        this.se("win");
      }
      render() {
        const ctx = this.ctx, s = this.canvas.width / GRID;
        ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
        ctx.fillStyle = BG;
        ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);
        for (let bl of this.blocks) {
          ctx.save();
          ctx.globalAlpha = 1;
          ctx.fillStyle = bl.color();
          if (bl.y === GRID / 2 - 1 || bl.y === GRID / 2) { // Boundary line blocks
            ctx.strokeStyle = "#FFF";
            ctx.lineWidth = 3;
          } else {
            ctx.strokeStyle = "#444";
            ctx.lineWidth = 1.1;
          }
          ctx.beginPath();
          ctx.rect((bl.x + 0.03) * s, (bl.y + 0.03) * s, s * 0.93, s * 0.93);
          ctx.fill();
          ctx.stroke();
          ctx.restore();
        }
        for (let pid = 0; pid < 2; pid++) {
          let p = this.paddles[pid];
          ctx.save();
          ctx.fillStyle = "#FFFFFF"; // Paddle color
          ctx.shadowColor = pid ? PADDLE_C : PADDLE_P; // Use defined constants for consistency
          ctx.shadowBlur = 13;
          ctx.beginPath();
          ctx.roundRect((p.x - PADDLE_WIDTH / 2) * s, (p.y - PADDLE_HALF_HEIGHT) * s, s * PADDLE_WIDTH, s * (PADDLE_HALF_HEIGHT * 2), s * 0.18);
          ctx.fill();
          ctx.restore();
        }
        for (let pid = 0; pid < 2; pid++) {
          let b = this.balls[pid];
          ctx.save();
          ctx.beginPath();
          ctx.arc(b.x * s, b.y * s, s * BALL_R, 0, 2 * Math.PI);
          ctx.fillStyle = "#FFFFFF"; // Ball color
          ctx.shadowColor = pid ? BALL_C : BALL_P; // Use defined constants for consistency
          ctx.shadowBlur = 20;
          ctx.globalAlpha = 0.95;
          ctx.fill();
          ctx.restore();
        }
        
        // MODIFIED: Use cached elements for score updates
        let pscore = 0, cscore = 0;
        for (let bl of this.blocks) {
          if (bl.owner === 0) pscore++;
          else if (bl.owner === 1) cscore++;
        }
        this.playerScoreEl.textContent = pscore;
        this.cpuScoreEl.textContent = cscore;
      }
      // MODIFIED: predictBallLandingX now takes targetY for prediction
      predictBallLandingX(ball, targetY) {
        let x = ball.x, y = ball.y, vx = ball.vx, vy = ball.vy;
        // Predict for a maximum number of steps or until targetY is crossed
        for (let i = 0; i < 180; i++) { // Increased steps for safety, though usually less are needed
          x += vx; y += vy;
          if (x - ball.r < 0) { x = ball.r; vx *= -1; }
          if (x + ball.r > GRID) { x = GRID - ball.r; vx *= -1; }
          
          // Stop prediction if the ball has crossed or reached the target Y, considering its direction
          if (vy < 0 && y <= targetY) break; // Moving up (towards CPU), stop if at or above CPU paddle
          if (vy > 0 && y >= targetY) break; // Moving down (towards Player), stop if at or below Player paddle
          
          // Added: Prevent prediction from going way off screen if something is wrong
          if (y < -GRID || y > GRID * 2) break; 
        }
        return x;
      }
    }

    // --- カウントダウン＆スタート ---
    let g;
    function startCountdownThenPlay() {
      const cd = document.getElementById("countdown");
      const start = document.getElementById("start");
      const result = document.getElementById("result");
      start.style.display = "none"; result.style.display = "none";
      cd.style.display = "flex";
      let count = 3;
      const countNum = document.getElementById("count-number");
      countNum.textContent = count;
      let countdownSE = () => {
        let a = document.getElementById("startSE");
        if (a) { a.currentTime = 0; a.play().catch(() => { }); }
      }
      countdownSE();
      let interval = setInterval(() => {
        count--;
        if (count > 0) {
          countNum.textContent = count;
          countdownSE();
        } else if (count === 0) {
          countNum.textContent = "START!";
          countdownSE();
        } else {
          clearInterval(interval);
          cd.style.display = "none";
          g = new Game();
          setupVirtualPad(g);
          setTimeout(() => g.start(), 100); // Small delay before game actually starts
        }
      }, 800); // Countdown interval
    }
    document.getElementById("playbtn").onclick = startCountdownThenPlay;

    // --- バーチャルパッド ---
    function setupVirtualPad(gameInstance) {
      const pad = document.getElementById("virtualPad");
      const padInner = document.getElementById("padInner");
      if (!pad || !padInner) return;
      let padActive = false, padStartX = 0, lastMoveDelta = 0; // Renamed lastMove to lastMoveDelta for clarity
      const PAD_SENSITIVITY = 0.048; 
      function resetPadVisual() {
        padInner.style.transition = "transform 0.17s";
        padInner.style.transform = "translateX(0px)";
        pad.classList.remove("active");
      }
      pad.onpointerdown = function (e) {
        if (!gameInstance || gameInstance.state !== "playing") return;
        padActive = true; pad.classList.add("active");
        pad.setPointerCapture(e.pointerId);
        padStartX = e.clientX; 
        padInner.style.transition = "none"; 
        lastMoveDelta = 0; // Reset delta accumulator on new touch
      };
      pad.onpointermove = function (e) {
        if (!padActive || !gameInstance || gameInstance.state !== "playing") return;
        const currentDeltaX = e.clientX - padStartX;
        padInner.style.transform = `translateX(${Math.max(-36, Math.min(36, currentDeltaX))}px)`;
        
        // Calculate movement since last processed move event
        const moveAmount = currentDeltaX - lastMoveDelta;
        if (Math.abs(moveAmount) > 2) { // Threshold to avoid tiny jitters, adjust if needed
          gameInstance.paddles[0].moveTo(gameInstance.paddles[0].x + moveAmount * PAD_SENSITIVITY);
          lastMoveDelta = currentDeltaX; // Update last processed delta
        }
      };
      function endPadInteraction(e) {
        if (padActive) {
          padActive = false; 
          resetPadVisual(); 
          pad.releasePointerCapture(e.pointerId);
          lastMoveDelta = 0; // Reset delta
        }
      }
      pad.onpointerup = endPadInteraction;
      pad.onpointercancel = endPadInteraction; // ADDED: Handle pointer cancel
      pad.onpointerleave = (e) => { // Only reset if it's truly leaving and still active (e.g. mouse drag out)
          if (padActive && e.pointerType === 'mouse') { // Typically for mouse; touch usually ends with pointerup
            endPadInteraction(e);
          }
      };
    }
  </script>
</body>
</html>
