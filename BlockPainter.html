<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8">
  <title>Block Painter</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no, viewport-fit=cover">
  <style>
    @import url('https://fonts.googleapis.com/css2?family=Orbitron:wght@700&family=Roboto+Mono:wght@400;700&display=swap');
    html, body { margin:0; padding:0; width:100vw; height:100vh; overflow:hidden; background:oklch(20% 0.02 280);}
    body {
      min-height: 100vh;
      font-family:'Roboto Mono', 'Segoe UI', Verdana, 'ヒラギノ角ゴ ProN', Arial, sans-serif;
      display:flex; flex-direction:column; align-items:center; justify-content:center;
    }
    #bg-glitch {
      z-index:0; position:fixed; top:0; left:0; width:100vw; height:100vh; pointer-events:none;
      background:
        repeating-linear-gradient(135deg, oklch(22% 0.01 270) 0 3px, transparent 3px 14px),
        repeating-linear-gradient(-45deg, oklch(25% 0.08 290) 0 2px, transparent 2px 18px),
        linear-gradient(120deg, oklch(22% 0.01 270) 65%, oklch(85% 0.15 200) 120%);
      opacity:0.75;
      animation:bgGlitch 4s infinite linear alternate;
      filter: blur(1.5px) brightness(1.15) contrast(1.05);
    }
    @keyframes bgGlitch {
      0% { background-position: 0 0,0 0,0 0;}
      25% { background-position: 8px 4px, -15px 18px, 0 20px;}
      50% { background-position: -6px -8px, 10px 22px, 0 -10px;}
      100% { background-position: 0 0,0 0,0 0;}
    }
    #gamebox {
      width:100vw; max-width:540px; position:relative; z-index:1;
      display:flex; flex-direction:column; align-items:center;
      backdrop-filter: blur(2.8px) brightness(1.03);
      background:rgba(32,30,45,0.22); border-radius:22px; box-shadow:0 0 34px oklch(75% 0.20 30 / 0.10);
    }
    #game {
      width:96vw; height:96vw; max-width:96vw; max-height:76vh; outline:none;
      border-radius:3vw; touch-action:none;
      box-shadow: 0 0 44px oklch(85% 0.16 330 / 0.11), 0 0 8px oklch(85% 0.15 200 / 0.23) inset;
      background:rgba(32,32,48,0.18);
      border:2px solid oklch(85% 0.15 200 / 0.44);
      margin-top:12px;
    }
    #ui {
      width:96vw; max-width:96vw;
      display:flex;justify-content:space-between;align-items:center;
      margin:1.5vw 0 0 0; font-size:5vw; user-select:none;
    }
    .glass-card {
      background:rgba(28,30,38,0.29);
      border-radius:16px; border:1px solid oklch(85% 0.15 200 / 0.45);
      box-shadow:0 0 12px oklch(80% 0.18 330 / 0.25) inset,0 0 8px oklch(80% 0.18 330 / 0.05);
      padding:1.5vw 4vw;
      min-width:17vw;text-align:center;
      font-weight:600;
      letter-spacing:0.02em;
      color:oklch(95% 0.01 0);
      font-family:'Orbitron', 'Roboto Mono', monospace;
      text-shadow:0 0 4px oklch(85% 0.15 200 / 0.22);
      margin:0 2vw;
      position:relative;
      overflow:hidden;
      transition:box-shadow 0.3s;
    }
    .glass-card:after {
      content:""; display:block; position:absolute;top:0;left:0;width:100%;height:100%;
      background:linear-gradient(60deg, transparent 40%, oklch(85% 0.15 200 / 0.04) 70%, transparent 100%);
      pointer-events:none;
    }
    #scoreP { background: oklch(75% 0.20 30 / 0.17); border:1px solid oklch(75% 0.20 30); }
    #scoreC { background: oklch(75% 0.20 230 / 0.13); border:1px solid oklch(75% 0.20 230); }
    #timer {
      text-align:center;
      background:linear-gradient(90deg, oklch(85% 0.15 200 / 0.13), oklch(80% 0.18 330 / 0.11));
      color:oklch(95% 0.01 0); font-size:6vw;
      font-family:'Orbitron',monospace;
      border-radius:2vw;
      padding:1vw 5vw; min-width:20vw;
      letter-spacing:0.05em;
      border:2px solid oklch(80% 0.18 330 / 0.44);
      margin:0 2vw;
      box-shadow:0 0 0.8vw oklch(85% 0.15 200 / 0.25);
      font-weight:bold;
    }
    #result,#start,#countdown {
      position:absolute;left:0;top:0;width:100%;height:100%;
      display:flex;flex-direction:column;align-items:center;justify-content:center;
      z-index:10;
      background:rgba(18,18,28,0.93);
      backdrop-filter:blur(4px);
      animation:fadeIn 0.7s;
    }
    @keyframes fadeIn { from { opacity:0;} to {opacity:1;} }
    #result,#start,#countdown{transition:opacity 0.3s;}
    #result{display:none;}
    #winner{color:oklch(82% 0.21 40);font-size:8vw;margin-bottom:2vw;font-family:'Orbitron',sans-serif;letter-spacing:0.08em;text-shadow:0 3px 12px oklch(98% 0.05 30),0 1px 2px oklch(22% 0.01 270);}
    #reason{color:oklch(90% 0.05 80);font-size:4.5vw;margin-bottom:1vw;text-align:center;}
    .cpk-btn {
      font-size:6vw; padding:3vw 14vw; margin-top:4vw;
      border-radius:3vw; border:none;
      background:linear-gradient(90deg, oklch(80% 0.18 330), oklch(85% 0.15 200));
      color:oklch(95% 0.01 0);
      font-weight:700; letter-spacing:0.08em; min-width:40vw;
      box-shadow:0 0 12px oklch(80% 0.18 330 / 0.20), 0 0 32px oklch(85% 0.15 200 / 0.12);
      outline:2px solid oklch(95% 0.01 0 / 0.24);
      font-family:'Orbitron',sans-serif;
      cursor:pointer;transition:transform 0.2s,box-shadow 0.2s;
      position:relative;overflow:hidden;
    }
    .cpk-btn:hover,.cpk-btn:focus {
      transform:scale(1.07);
      box-shadow:0 0 22px oklch(85% 0.15 200 / 0.52);
    }
    #start h1{
      color:oklch(80% 0.18 330); font-size:9vw;
      font-family:'Orbitron',sans-serif;font-weight:800;
      letter-spacing:0.12em;margin:0 0 3vw 0;
      text-shadow:0 3px 12px oklch(85% 0.15 200 / 0.38);
    }
    #start p{color:oklch(98% 0.02 140);background:oklch(30% 0.03 120 / 0.39);padding:3vw 7vw;border-radius:2vw;font-size:4vw;margin-bottom:7vw;line-height:1.7;box-shadow:0 0 10px oklch(52% 0.12 230);}
    #orientationWarning {
      display:none; position:fixed;top:0;left:0;width:100vw;height:100vh;
      background:oklch(98% 0.02 120);color:oklch(58% 0.20 20);z-index:10000;
      flex-direction:column;justify-content:center;align-items:center;text-align:center;
      font-size:5vw;font-weight:bold;
    }
    #countdown {
      font-family: 'Orbitron', sans-serif; color:oklch(80% 0.18 330);
      font-size:16vw; letter-spacing:0.05em; text-shadow:0 0 28px oklch(80% 0.18 330 / 0.64),0 0 4px oklch(85% 0.15 200 / 0.38);
      display:flex;align-items:center;justify-content:center; flex-direction:column;
      opacity:1; animation:countPulse 0.8s infinite alternate;
    }
    @keyframes countPulse {0%{text-shadow:0 0 8px oklch(80% 0.18 330 / 0.36);}100%{text-shadow:0 0 36px oklch(85% 0.15 200 / 0.44);}}
    #countdown-label{
      font-size:4vw; margin-bottom:4vw;color:oklch(95% 0.01 0);
      text-shadow:0 0 7px oklch(80% 0.18 330 / 0.22);
      letter-spacing:0.09em;font-family:'Roboto Mono',monospace;
    }
    @media (orientation: landscape){
      body{justify-content:center;}
      #game{height:60vw;}
      #ui{font-size:3vw;}
      .glass-card,#timer{font-size:3vw;}
      #start h1{font-size:5vw;}
      #start p{font-size:2.5vw;}
      .cpk-btn{font-size:3vw;padding:2vw 8vw;}
      #orientationWarning{font-size:2.5vw;}
      #countdown{font-size:7vw;}
    }
  </style>
</head>
<body>
  <div id="bg-glitch"></div>
  <div id="gamebox">
    <canvas id="game" width="800" height="800" tabindex="0"></canvas>
    <div id="ui">
      <div id="scoreP" class="glass-card">0</div>
      <div id="timer" class="glass-card">30</div>
      <div id="scoreC" class="glass-card">0</div>
    </div>
    <div id="result" role="dialog" aria-modal="true">
      <div id="winner"></div>
      <div id="reason"></div>
      <button class="cpk-btn" onclick="location.reload()">もう一度遊ぶ</button>
    </div>
    <div id="start" role="dialog" aria-modal="true">
      <h1>Block Painter</h1>
      <p>新時代のカラーバトル。サイバーパンクな盤面を塗れ！<br>「はじめる」ボタン後3秒カウントダウン→スタート</p>
      <button class="cpk-btn" id="playbtn">はじめる</button>
    </div>
    <div id="countdown" style="display:none;">
      <span id="countdown-label">ゲーム開始まで</span>
      <span id="count-number">3</span>
    </div>
  </div>
  <div id="orientationWarning">縦画面でご利用ください</div>
  <audio id="hit" src="https://cdn.jsdelivr.net/gh/thisable/audio@main/pop.mp3" preload="auto"></audio>
  <audio id="paint" src="https://cdn.jsdelivr.net/gh/thisable/audio@main/ping.mp3" preload="auto"></audio>
  <audio id="win" src="https://cdn.jsdelivr.net/gh/thisable/audio@main/win.mp3" preload="auto"></audio>
  <audio id="startSE" src="https://cdn.jsdelivr.net/gh/thisable/audio@main/startbeep.mp3" preload="auto"></audio>
  <script>
    // 配色はOKLCH徹底
    const GRID = 8, BLOCKS = 64,
      BLOCK_INIT = "oklch(91% 0.11 140)",    // 明るい黄緑
      BLOCK_P = "oklch(82% 0.21 40)",        // プレイヤーブロック: オレンジ寄り
      BLOCK_C = "oklch(82% 0.20 225)",       // CPUブロック: パープル
      PADDLE_P = "oklch(45% 0.12 45)",       // パドル：ダークオレンジ
      PADDLE_C = "oklch(33% 0.13 260)",      // パドル：ダークパープル
      BALL_P = "oklch(78% 0.19 34)",         // ボール：やや明るいオレンジ
      BALL_C = "oklch(75% 0.20 230)",        // ボール：やや明るい青紫
      BG = "oklch(22% 0.01 270)";
    const PADDLE_WIDTH = 1.8, BALL_R = 0.35, MATCH = 30, FPS = 60;
    const BLOCK_TYPES = [
      { type: "Normal", score: 1, prob: 0.83 },
      { type: "Double", score: 1, hits: 2, prob: 0.11 },
      { type: "Bonus", score: 2, prob: 0.06 }
    ];
    function getColor(owner) {
      if (owner === 0) return BLOCK_P;
      if (owner === 1) return BLOCK_C;
      return BLOCK_INIT;
    }
    class Block {
      constructor(x, y, typeDef) {
        this.x = x; this.y = y;
        this.type = typeDef.type;
        this.score = typeDef.score;
        this.hits = 0;
        this.maxHits = typeDef.hits || 1;
        this.owner = -1;
      }
      hit(pid) {
        if (this.owner === pid && (this.type !== "Double" || this.hits >= this.maxHits)) return { action: "none" };
        const prev = this.owner; this.hits++;
        if (this.hits >= this.maxHits) { this.owner = pid; return { action: "paint", prevOwner: prev, score: this.score }; }
        else if (this.type === "Double") { return { action: "partial_hit" }; }
        return { action: "none" };
      }
      color() { return getColor(this.owner); }
    }
    class Paddle {
      constructor(y, color) { this.x = GRID / 2; this.y = y; this.color = color; this.w = PADDLE_WIDTH; }
      moveTo(nx) { this.x = Math.max(this.w / 2, Math.min(GRID - this.w / 2, nx)); }
    }
    class Ball {
      constructor(pid, color, startY) { this.pid = pid; this.x = GRID / 2; this.y = startY; this.r = BALL_R; this.color = color; this.reset(); }
      reset() {
        this.x = GRID / 2; this.y = this.pid ? 1.3 : GRID - 1.3;
        this.vx = (Math.random() - 0.5) * 0.045;
        this.vy = this.pid ? -0.10 : 0.10;
      }
      move() { this.x += this.vx; this.y += this.vy; }
    }
    class Game {
      constructor() {
        this.canvas = document.getElementById('game');
        this.ctx = this.canvas.getContext('2d');
        this.blocks = []; this.paddles = [null, null]; this.balls = [null, null]; this.score = [0, 0];
        this.timer = MATCH; this.state = "wait"; this.touchId = null; this.waitingForStart = true;
        this.init(); this.resize(); this.setupInput(); this.loopBind = this.loop.bind(this);
      }
      randBlockType() {
        let t = Math.random();
        for (let i = 0, sum = 0; i < BLOCK_TYPES.length; i++) { sum += BLOCK_TYPES[i].prob; if (t < sum) return BLOCK_TYPES[i]; }
        return BLOCK_TYPES[0];
      }
      init() {
        this.blocks = [];
        for (let y = 0; y < GRID; y++) for (let x = 0; x < GRID; x++) this.blocks.push(new Block(x, y, this.randBlockType()));
        this.paddles[0] = new Paddle(GRID - 0.5, PADDLE_P); this.paddles[1] = new Paddle(0.5, PADDLE_C);
        this.balls[0] = new Ball(0, BALL_P, GRID - 1.3); this.balls[1] = new Ball(1, BALL_C, 1.3);
        this.score = [0, 0]; this.timer = MATCH; this.state = "wait"; this.waitingForStart = true;
        document.getElementById("scoreP").textContent = 0;
        document.getElementById("scoreC").textContent = 0;
        document.getElementById("timer").textContent = MATCH;
      }
      setupInput() {
        let self = this, canvas = this.canvas;
        canvas.addEventListener("pointerdown", e => {
          if (self.state !== "playing") return; self.handlePointer(e); self.touchId = e.pointerId; canvas.setPointerCapture(e.pointerId);
        });
        canvas.addEventListener("pointermove", e => { if (self.state !== "playing" || e.pointerId !== self.touchId) return; self.handlePointer(e); });
        canvas.addEventListener("pointerup", e => { if (e.pointerId === self.touchId) { self.touchId = null; canvas.releasePointerCapture(e.pointerId); } });
        canvas.addEventListener("pointerleave", e => { if (e.pointerId === self.touchId) { self.touchId = null; canvas.releasePointerCapture(e.pointerId); } });
        window.addEventListener("keydown", e => {
          if (self.state !== "playing") return;
          if (e.key === "ArrowLeft") { self.paddles[0].moveTo(self.paddles[0].x - 0.65); }
          if (e.key === "ArrowRight") { self.paddles[0].moveTo(self.paddles[0].x + 0.65); }
        });
        window.addEventListener("resize", () => { self.resize(); enforcePortrait(); });
      }
      handlePointer(e) {
        const rect = this.canvas.getBoundingClientRect(), x = e.clientX - rect.left;
        const nx = GRID * x / this.canvas.width;
        this.paddles[0].moveTo(nx);
      }
      resize() {
        const s = Math.min(window.innerWidth * 0.96, window.innerHeight * 0.70, 540);
        this.canvas.width = this.canvas.height = s;
      }
      start() {
        if (!this.waitingForStart) return;
        this.state = "playing"; this.waitingForStart = false;
        requestAnimationFrame(this.loopBind);
      }
      loop() {
        if (this.state !== "playing") return;
        this.timer -= 1 / FPS; if (this.timer <= 0) { this.finish("時間切れ"); return; }
        document.getElementById("timer").textContent = String(Math.ceil(this.timer));
        let cpuPaddle = this.paddles[1], cpuBall = this.balls[1];
        let targetX = cpuBall.y < GRID / 2 ? cpuBall.x : GRID / 2;
        cpuPaddle.moveTo(cpuPaddle.x + (targetX - cpuPaddle.x) * 0.12);
        for (let pid = 0; pid < 2; pid++) {
          let b = this.balls[pid], p = this.paddles[pid];
          b.move();
          if (Math.abs(b.x - p.x) < p.w / 2 && Math.abs(b.y - p.y) < 0.44 && ((pid === 0 && b.vy > 0) || (pid === 1 && b.vy < 0))) {
            b.vy *= -1; b.vx += (b.x - p.x) * 0.09; b.vx = Math.max(-0.17, Math.min(0.17, b.vx)); b.y = pid === 0 ? p.y - 0.45 : p.y + 0.45; this.se("hit");
          }
          if (b.x - b.r < 0) { b.x = b.r; b.vx *= -1; this.se("hit"); }
          if (b.x + b.r > GRID) { b.x = GRID - b.r; b.vx *= -1; this.se("hit"); }
          if (pid === 0 && (b.y > GRID - 0.1)) { this.finish("あなたがミスして終了"); return; }
          if (pid === 1 && (b.y < 0.1)) { this.finish("CPUがミスしてあなたの勝ち！"); return; }
          for (let bl of this.blocks) {
            const blockRight = bl.x + 1, blockBottom = bl.y + 1;
            if (b.x + b.r > bl.x && b.x - b.r < blockRight && b.y + b.r > bl.y && b.y - b.r < blockBottom) {
              if (bl.owner === pid && (bl.type !== "Double" || bl.hits >= bl.maxHits)) continue;
              const hitOutcome = bl.hit(pid);
              if (hitOutcome.action === "paint") {
                if (hitOutcome.prevOwner !== -1 && hitOutcome.prevOwner !== pid) this.score[hitOutcome.prevOwner] = Math.max(0, this.score[hitOutcome.prevOwner] - bl.score);
                this.score[pid] += bl.score; this.se("paint"); b.vy *= -1; break;
              } else if (hitOutcome.action === "partial_hit") { this.se("hit"); break; }
            }
          }
        }
        document.getElementById("scoreP").textContent = this.score[0];
        document.getElementById("scoreC").textContent = this.score[1];
        this.render();
        requestAnimationFrame(this.loopBind);
      }
      se(name) {
        let a = document.getElementById(name);
        if (a) { a.currentTime = 0; a.play().catch(() => {});}
      }
      finish(reason) {
        this.state = "result"; let winnerText, reasonText = reason || "";
        if (reason && reason.includes("CPUがミス")) { winnerText = "あなたの勝ち！";
        } else if (reason && reason.includes("あなたがミス")) { winnerText = "CPUの勝ち";
        } else {
          if (this.score[0] > this.score[1]) { winnerText = "あなたの勝ち！";}
          else if (this.score[1] > this.score[0]) { winnerText = "CPUの勝ち";}
          else { winnerText = "引き分け！";}
        }
        winnerText += ` (あなた: ${this.score[0]} - CPU: ${this.score[1]})`;
        document.getElementById("result").style.display = "flex";
        document.getElementById("winner").textContent = winnerText;
        document.getElementById("reason").textContent = reasonText;
        this.se("win");
      }
      render() {
        const ctx = this.ctx, s = this.canvas.width / GRID;
        ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
        ctx.fillStyle = BG; ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);
        for (let bl of this.blocks) {
          ctx.save(); ctx.globalAlpha = 1; ctx.fillStyle = bl.color();
          ctx.strokeStyle = "oklch(99% 0.01 80)";
          ctx.lineWidth = (bl.type === "Bonus" || (bl.type === "Double" && bl.hits < bl.maxHits && bl.owner === -1)) ? 2 : 1.2;
          ctx.beginPath(); ctx.rect((bl.x + 0.03) * s, (bl.y + 0.03) * s, s * 0.93, s * 0.93); ctx.fill(); ctx.stroke();
          if (bl.type === "Bonus") {
            ctx.strokeStyle = "oklch(92% 0.18 100)"; ctx.lineWidth = Math.min(s * 0.1, 4);
            ctx.strokeRect((bl.x + 0.18) * s, (bl.y + 0.18) * s, s * 0.6, s * 0.6);
          }
          if (bl.type === "Double" && bl.hits === 1 && bl.owner === -1) {
            ctx.fillStyle = "oklch(60% 0.14 320)";
            ctx.beginPath(); ctx.arc((bl.x + 0.5) * s, (bl.y + 0.5) * s, s * 0.15, 0, 2 * Math.PI); ctx.fill();
          } else if (bl.type === "Double" && bl.hits < bl.maxHits && bl.owner < 0) {
            ctx.globalAlpha = 0.25; ctx.fillStyle = "oklch(28% 0.05 300)";
            ctx.fillRect((bl.x + 0.26) * s, (bl.y + 0.26) * s, s * 0.44, s * 0.44);
          }
          ctx.restore();
        }
        for (let pid = 0; pid < 2; pid++) {
          let p = this.paddles[pid];
          ctx.save(); ctx.fillStyle = pid ? PADDLE_C : PADDLE_P;
          ctx.shadowColor = "oklch(90% 0.09 80)"; ctx.shadowBlur = 10;
          ctx.beginPath();
          ctx.roundRect((p.x - PADDLE_WIDTH / 2) * s, (p.y - 0.18) * s, s * PADDLE_WIDTH, s * 0.44, s * 0.21); ctx.fill();
          ctx.restore();
        }
        for (let pid = 0; pid < 2; pid++) {
          let b = this.balls[pid];
          ctx.save(); ctx.beginPath();
          ctx.arc(b.x * s, b.y * s, s * BALL_R, 0, 2 * Math.PI);
          ctx.fillStyle = pid ? BALL_C : BALL_P;
          ctx.shadowColor = pid ? BALL_C : BALL_P; ctx.shadowBlur = 16; ctx.globalAlpha = 0.97; ctx.fill();
          ctx.restore();
        }
      }
    }
    let g;
    function startCountdownThenPlay() {
      const cd = document.getElementById("countdown");
      const start = document.getElementById("start");
      const result = document.getElementById("result");
      start.style.display = "none"; result.style.display = "none";
      cd.style.display = "flex";
      let count = 3;
      const countNum = document.getElementById("count-number");
      countNum.textContent = count;
      let countdownSE = () => {
        let a = document.getElementById("startSE");
        if(a){a.currentTime=0;a.play().catch(()=>{});}
      }
      countdownSE();
      let interval = setInterval(() => {
        count--;
        if(count>0){
          countNum.textContent = count;
          countdownSE();
        }else if(count===0){
          countNum.textContent = "START!";
          countdownSE();
        }else{
          clearInterval(interval);
          cd.style.display = "none";
          g = new Game();
          setTimeout(()=>g.start(), 120);
        }
      }, 800);
    }
    document.getElementById("playbtn").onclick = startCountdownThenPlay;

    function enforcePortrait() {
      const w = document.getElementById('orientationWarning');
      if (w) {
        if (window.innerWidth > window.innerHeight && window.matchMedia("(orientation: landscape)").matches) {
          w.style.display = 'flex';
        } else {
          w.style.display = 'none';
        }
      }
    }
    window.addEventListener("resize", enforcePortrait);
    document.addEventListener("DOMContentLoaded", enforcePortrait);
  </script>
</body>
</html>
