<!DOCTYPE html>
<html lang="ja">

<head>
  <meta charset="UTF-8">
  <title>Block Painter</title>
  <meta name="viewport"
    content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no, viewport-fit=cover">
  <link
    href="https://fonts.googleapis.com/css2?family=Orbitron:wght@700;900&family=Roboto+Mono:wght@400;700&display=swap"
    rel="stylesheet">
  <style>
    html,
    body {
      height: 100dvh;
      width: 100dvw;
      margin: 0;
      padding: 0;
      background: #181824;
      overflow: hidden;
      box-sizing: border-box;
      /* Safe Area for iOS/Android */
      padding-top: env(safe-area-inset-top, 0px);
      padding-bottom: env(safe-area-inset-bottom, 0px);
      padding-left: env(safe-area-inset-left, 0px);
      padding-right: env(safe-area-inset-right, 0px);
      overscroll-behavior: none;
      touch-action: none;
    }

    body {
      min-height: 100dvh;
      min-width: 100dvw;
      display: flex;
      align-items: center;
      justify-content: center;
      font-family: 'Roboto Mono', 'Segoe UI', Verdana, Arial, 'ヒラギノ角ゴ ProN', sans-serif;
      color: #FFF;
      font-size: clamp(16px, 5vw, 20px);
      background: #181824;
    }

    #gamebox {
      width: min(96vw, 96vh, 520px);
      height: min(96vw, 96vh, 520px);
      max-width: 98vw;
      max-height: 98vh;
      margin: auto;
      background: rgba(35, 35, 56, 0.98);
      border-radius: 18px;
      box-shadow: 0 2px 16px #0CFDFF44;
      padding: 10px 0 20px 0;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      position: relative;
    }

    #ui {
      width: 90%;
      max-width: 96vw;
      display: flex;
      justify-content: space-between;
      align-items: center;
      gap: 14px;
      margin: 8px 0 0 0;
      font-size: 18px;
      user-select: none;
    }

    .hud {
      font-family: 'Orbitron', sans-serif;
      font-size: 17px;
      font-weight: bold;
      letter-spacing: 1.5px;
      display: flex;
      align-items: center;
      min-width: 60px;
      padding: 0 6px;
    }

    .hud-player {
      color: #00FFD0;
    }

    .hud-cpu {
      color: #FF2080;
      flex-direction: row-reverse;
    }

    .arrow {
      font-size: 1.3em;
      margin: 0 5px;
    }

    #timer {
      background: linear-gradient(90deg, #181824 40%, #00FFD0 100%);
      border: 1.5px solid #00FFD0;
      border-radius: 12px;
      color: #fff;
      font-size: 20px;
      padding: 6px 18px;
      font-family: 'Orbitron', sans-serif;
      letter-spacing: 1.2px;
      box-shadow: 0 0 8px #0CFDFF44;
      text-align: center;
      min-width: 54px;
    }

    #game {
      width: 90%;
      height: 90%;
      max-width: 96vw;
      max-height: 78vw;
      aspect-ratio: 1 / 1;
      border-radius: 3vw;
      box-shadow: 0 0 28px #FF208055, 0 0 8px #00FFD0 inset;
      background: rgba(32, 32, 48, 0.18);
      border: 2px solid #00FFD0;
      margin-top: 10px;
      display: block;
      touch-action: none;
      outline: none;
    }

    .game-title,
    #start h1 {
      font-family: 'Orbitron', sans-serif;
      font-size: clamp(28px, 8vw, 36px);
      letter-spacing: -0.5px;
      color: #00FFD0;
      text-shadow: 0 0 14px #00FFD0, 0 1px 0 #232338;
      font-weight: 900;
      margin: 0 0 8px 0;
      text-align: center;
      text-transform: uppercase;
    }

    #start p {
      color: #c8fff6;
      background: rgba(0, 255, 208, 0.11);
      padding: 16px 12px;
      border-radius: 10px;
      font-size: 17px;
      margin-bottom: 22px;
      line-height: 1.5;
      box-shadow: 0 0 6px #FF208044;
      text-align: center;
      font-family: 'Roboto Mono', monospace;
    }

    .game-btn {
      background: linear-gradient(90deg, #00FFD0, #FF2080 100%);
      color: #181824;
      font-family: 'Orbitron', sans-serif;
      font-size: 20px;
      letter-spacing: 2px;
      border-radius: 16px;
      border: none;
      padding: 14px 0;
      margin: 14px 0 0 0;
      min-width: 72vw;
      min-height: 48px;
      font-weight: 800;
      box-shadow: 0 4px 20px #0CFDFF44;
      outline: 2px solid #00FFD044;
      position: relative;
      transition: transform 0.15s, box-shadow 0.18s, background 0.2s;
      cursor: pointer;
      display: block;
      text-align: center;
      outline-offset: 2px;
    }

    .game-btn:active,
    .game-btn:focus {
      transform: scale(0.97);
      box-shadow: 0 2px 12px #FF208088;
      background: linear-gradient(90deg, #FF2080, #00FFD0 100%);
      outline: 2.5px solid #FF2080;
    }

    #result,
    #start,
    #countdown {
      position: absolute;
      inset: 0;
      width: 100%;
      height: 100%;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      z-index: 10;
      background: rgba(18, 18, 36, 0.96);
      backdrop-filter: blur(6px) brightness(1.12);
      border-radius: 18px;
      box-shadow: 0 0 24px #00FFD044;
      /* 余白も自動で中央寄せ */
      padding: 5vw 2vw 3vw 2vw;
      color: #fff;
      animation: fadeIn 0.7s;
      transition: opacity 0.3s;
      /* これで親のサイズぴったり中央 */
      max-width: 100%;
      max-height: 100%;
      margin: 0;
    }

    #result {
      display: none;
    }

    @keyframes fadeIn {
      from {
        opacity: 0;
      }

      to {
        opacity: 1;
      }
    }

    #winner {
      color: #00FFD0;
      font-size: 29px;
      margin-bottom: 8px;
      font-family: 'Orbitron', sans-serif;
      letter-spacing: 0.08em;
      text-shadow: 0 2px 16px #00FFD0, 0 1px 2px #232338;
      text-align: center;
      font-weight: 900;
    }

    #reason {
      color: #FF2080;
      font-size: 18px;
      margin-bottom: 12px;
      text-align: center;
      font-family: 'Roboto Mono', monospace;
      text-shadow: 0 1px 6px #FF2080, 0 0 2px #fff;
    }

    #countdown {
      font-family: 'Orbitron', sans-serif;
      color: #00FFD0;
      font-size: 46px;
      letter-spacing: 0.05em;
      text-shadow: 0 0 18px #FF2080, 0 0 7px #00FFD0;
      display: flex;
      align-items: center;
      justify-content: center;
      flex-direction: column;
      opacity: 1;
      animation: countPulse 0.8s infinite alternate;
    }

    @keyframes countPulse {
      0% {
        text-shadow: 0 0 7px #FF2080;
      }

      100% {
        text-shadow: 0 0 26px #00FFD0;
      }
    }

    #countdown-label {
      font-size: 19px;
      margin-bottom: 10px;
      color: #fff;
      text-shadow: 0 0 5px #FF2080;
    }

    #orientationWarning {
      display: none;
      position: fixed;
      top: 0;
      left: 0;
      width: 100vw;
      height: 100dvh;
      background: #00FFD0;
      color: #181824;
      z-index: 10000;
      flex-direction: column;
      justify-content: center;
      align-items: center;
      text-align: center;
      font-size: 21px;
      font-family: 'Orbitron', sans-serif;
      font-weight: bold;
      letter-spacing: 2px;
      box-shadow: 0 2px 16px #00FFD044;
    }

    /* バーチャルパッド */
    #virtualPad {
      position: fixed;
      left: 50%;
      bottom: 22px;
      transform: translateX(-50%);
      width: 118px;
      height: 118px;
      border-radius: 50%;
      background: linear-gradient(135deg, #00FFD0 40%, #FF2080 120%);
      box-shadow: 0 4px 24px #00FFD044;
      display: none;
      /* 開始後にのみ出現 */
      align-items: center;
      justify-content: center;
      z-index: 2000;
      user-select: none;
      touch-action: none;
      opacity: 0.93;
      pointer-events: auto;
    }

    #padInner {
      width: 58px;
      height: 58px;
      border-radius: 50%;
      background: #181824;
      box-shadow: 0 2px 18px #fff8, 0 0 0 4px #fff3 inset;
      transition: transform 0.09s, box-shadow 0.09s;
      will-change: transform;
      pointer-events: none;
    }

    #virtualPad:active #padInner,
    #virtualPad.active #padInner {
      background: #222248;
      box-shadow: 0 4px 28px #00ffd099, 0 0 0 8px #ff208022 inset;
      transform: scale(1.12);
    }

    @media (max-width: 414px) {
      #gamebox {
        padding: 8px 0 12px 0;
      }

      .game-btn {
        font-size: 17px;
        min-height: 48px;
      }

      #timer {
        font-size: 17px;
      }

      #start h1,
      .game-title {
        font-size: 25px;
      }

      #virtualPad {
        width: 80px;
        height: 80px;
      }

      #padInner {
        width: 33px;
        height: 33px;
      }
    }

    @media (orientation: landscape) {
      #gamebox {
        width: min(60vw, 60vh, 380px);
        height: min(60vw, 60vh, 380px);
      }

      #game {
        height: 60vw;
      }

      #ui {
        font-size: 14px;
      }

      #timer {
        font-size: 13px;
      }

      #start h1,
      .game-title {
        font-size: 18px;
      }

      .game-btn {
        font-size: 13px;
        padding: 8px 0;
      }

      #orientationWarning {
        font-size: 15px;
      }

      #countdown {
        font-size: 28px;
      }

      #virtualPad {
        width: 54px;
        height: 54px;
      }

      #padInner {
        width: 21px;
        height: 21px;
      }
    }
  </style>
</head>

<body>
  <div id="gamebox">
    <div id="ui">
      <div class="hud hud-player"><span class="arrow">&#x25BC;</span>あなた</div>
      <div id="timer">30</div>
      <div class="hud hud-cpu">CPU<span class="arrow">&#x25B2;</span></div>
    </div>
    <canvas id="game" width="800" height="800" tabindex="0"></canvas>
    <div id="result" role="dialog" aria-modal="true">
      <div id="winner"></div>
      <div id="reason"></div>
      <button class="game-btn" onclick="location.reload()">もう一度遊ぶ</button>
    </div>
    <div id="start" role="dialog" aria-modal="true">
      <h1 class="game-title">Block Painter</h1>
      <p>画面下の<b>大きな円形パッド</b>に指を置き、左右にスライドしてパドルを操作してください。ピンチズームやスワイプなど<br>他の操作はゲーム中無効です。</p>
      <button class="game-btn" id="playbtn" role="button" aria-pressed="false">はじめる</button>
    </div>
    <div id="countdown" style="display:none;">
      <span id="countdown-label">ゲーム開始まで</span>
      <span id="count-number">3</span>
    </div>
  </div>
  <!-- バーチャルパッド：ゲーム進行中のみ下端中央に出現 -->
  <div id="virtualPad" aria-label="バーチャルパッド" tabindex="0">
    <div id="padInner"></div>
  </div>
  <div id="orientationWarning">縦画面でご利用ください</div>
  <audio id="hit" src="https://cdn.jsdelivr.net/gh/thisable/audio@main/pop.mp3" preload="auto"></audio>
  <audio id="paint" src="https://cdn.jsdelivr.net/gh/thisable/audio@main/ping.mp3" preload="auto"></audio>
  <audio id="win" src="https://cdn.jsdelivr.net/gh/thisable/audio@main/win.mp3" preload="auto"></audio>
  <audio id="startSE" src="https://cdn.jsdelivr.net/gh/thisable/audio@main/startbeep.mp3" preload="auto"></audio>
  <script>
    // タッチ系の全誤爆防止（ゲーム中のみバーチャルパッド以外全て無効）
    let isPlaying = false;
    document.addEventListener('touchstart', function (e) {
      if (isPlaying && !e.target.closest("#virtualPad")) e.preventDefault();
    }, { passive: false });
    document.addEventListener('touchmove', function (e) {
      if (isPlaying && !e.target.closest("#virtualPad")) e.preventDefault();
    }, { passive: false });
    document.addEventListener('touchend', function (e) {
      if (isPlaying && !e.target.closest("#virtualPad")) e.preventDefault();
    }, { passive: false });
    document.addEventListener('gesturestart', e => { if (isPlaying) e.preventDefault(); });
    document.addEventListener('gesturechange', e => { if (isPlaying) e.preventDefault(); });
    document.addEventListener('gestureend', e => { if (isPlaying) e.preventDefault(); });

    // スマホ特化なのでorientation only
    function enforcePortrait() {
      const w = document.getElementById('orientationWarning');
      if (w) {
        if (window.innerWidth > window.innerHeight && window.matchMedia("(orientation: landscape)").matches) {
          w.style.display = 'flex';
        } else {
          w.style.display = 'none';
        }
      }
    }
    window.addEventListener("resize", enforcePortrait);
    document.addEventListener("DOMContentLoaded", enforcePortrait);

    // ゲームのリサイズ: SafeAreaも考慮
    function getSafeAreaInset(styleProp, fallback = 0) {
      const val = parseInt(getComputedStyle(document.documentElement).getPropertyValue(styleProp));
      return isNaN(val) ? fallback : val;
    }

    // ブロック数を約30%減（12×12=144）
    const GRID = 12, BLOCKS = GRID * GRID,
      BLOCK_P = "#00FFD0", BLOCK_C = "#FF2080", BLOCK_N = "#232338",
      PADDLE_P = "#FFFFFF", PADDLE_C = "#FFFFFF", BALL_P = "#FFFFFF", BALL_C = "#FFFFFF",
      BG = "#181824";
    const PADDLE_WIDTH = 1.8, BALL_R = 0.18, MATCH = 30, FPS = 60;

    class Block {
      constructor(x, y) {
        this.x = x;
        this.y = y;
        this.type = "Normal";
        this.score = 1;
        this.hits = 0;
        this.maxHits = 1;
        this.owner = y < GRID / 2 ? 1 : 0;
      }
      hit(pid) {
        if (this.owner === pid) return { action: "none" };
        const prev = this.owner;
        this.owner = pid;
        return { action: "paint", prevOwner: prev, score: this.score };
      }
      color() {
        if (this.owner === 0) return BLOCK_P;
        if (this.owner === 1) return BLOCK_C;
        return BLOCK_N;
      }
    }
    class Paddle {
      constructor(y, color) { this.x = GRID / 2; this.y = y; this.color = color; this.w = PADDLE_WIDTH; }
      moveTo(nx) { this.x = Math.max(this.w / 2, Math.min(GRID - this.w / 2, nx)); }
    }
    class Ball {
      constructor(pid, color, startY) { this.pid = pid; this.x = GRID / 2; this.y = startY; this.r = BALL_R; this.color = color; this.reset(); }
      reset() {
        this.x = GRID / 2; this.y = this.pid ? 1.3 : GRID - 1.3;
        this.vx = (Math.random() - 0.5) * 0.045;
        this.vy = this.pid ? -0.10 : 0.10;
      }
      move() { this.x += this.vx; this.y += this.vy; }
    }
    class Game {
      constructor() {
        this.canvas = document.getElementById('game');
        this.ctx = this.canvas.getContext('2d');
        this.blocks = [];
        this.paddles = [null, null];
        this.balls = [null, null];
        this.score = [0, 0];
        this.timer = MATCH;
        this.state = "wait";
        this.waitingForStart = true;
        this.init();
        this.resize();
        this.loopBind = this.loop.bind(this);

        // ウィンドウリサイズ時も自動リサイズ
        window.addEventListener('resize', () => this.resize());
      }
      init() {
        this.blocks = [];
        for (let y = 0; y < GRID; y++) for (let x = 0; x < GRID; x++) this.blocks.push(new Block(x, y));
        this.paddles[0] = new Paddle(GRID - 0.5, PADDLE_P);
        this.paddles[1] = new Paddle(0.5, PADDLE_C);
        this.balls[0] = new Ball(0, BALL_P, GRID - 1.3);
        this.balls[1] = new Ball(1, BALL_C, 1.3);
        this.score = [0, 0];
        this.timer = MATCH;
        this.state = "wait";
        this.waitingForStart = true;
        document.getElementById("timer").textContent = MATCH;
      }
      resize() {
        // SafeAreaも考慮
        const safeTop = getSafeAreaInset('padding-top', 0);
        const safeBottom = getSafeAreaInset('padding-bottom', 0);
        const safeLeft = getSafeAreaInset('padding-left', 0);
        const safeRight = getSafeAreaInset('padding-right', 0);
        const safeW = window.innerWidth - safeLeft - safeRight;
        const safeH = window.innerHeight - safeTop - safeBottom;
        const s = Math.min(safeW * 0.96, safeH * 0.96, 520);
        this.canvas.width = this.canvas.height = s;
      }
      start() {
        if (!this.waitingForStart) return;
        this.state = "playing"; this.waitingForStart = false;
        isPlaying = true;
        document.getElementById("virtualPad").style.display = "flex";
        requestAnimationFrame(this.loopBind);
      }
      loop() {
        if (this.state !== "playing") return;
        this.timer -= 1 / FPS; if (this.timer <= 0) { this.finish("時間切れ"); return; }
        document.getElementById("timer").textContent = String(Math.ceil(this.timer));
        let cpuPaddle = this.paddles[1], cpuBall = this.balls[1];
        let targetX = cpuBall.y < GRID / 2 ? cpuBall.x : GRID / 2;
        cpuPaddle.moveTo(cpuPaddle.x + (targetX - cpuPaddle.x) * 0.13);
        for (let pid = 0; pid < 2; pid++) {
          let b = this.balls[pid], p = this.paddles[pid];
          b.move();
          if (Math.abs(b.x - p.x) < p.w / 2 && Math.abs(b.y - p.y) < 0.44 && ((pid === 0 && b.vy > 0) || (pid === 1 && b.vy < 0))) {
            b.vy *= -1; b.vx += (b.x - p.x) * 0.09; b.vx = Math.max(-0.17, Math.min(0.17, b.vx)); b.y = pid === 0 ? p.y - 0.45 : p.y + 0.45; this.se("hit");
          }
          if (b.x - b.r < 0) { b.x = b.r; b.vx *= -1; this.se("hit"); }
          if (b.x + b.r > GRID) { b.x = GRID - b.r; b.vx *= -1; this.se("hit"); }
          if (pid === 0 && (b.y > GRID - 0.1)) { this.finish("あなたがミスして終了"); return; }
          if (pid === 1 && (b.y < 0.1)) { this.finish("CPUがミスしてあなたの勝ち！"); return; }
          for (let bl of this.blocks) {
            if (b.x + b.r > bl.x && b.x - b.r < bl.x + 1 && b.y + b.r > bl.y && b.y - b.r < bl.y + 1) {
              if (bl.owner === pid) continue;
              const hitOutcome = bl.hit(pid);
              if (hitOutcome.action === "paint") {
                if (hitOutcome.prevOwner !== -1 && hitOutcome.prevOwner !== pid) this.score[hitOutcome.prevOwner] = Math.max(0, this.score[hitOutcome.prevOwner] - bl.score);
                this.score[pid] += bl.score; this.se("paint"); b.vy *= -1; break;
              }
            }
          }
        }
        this.render();
        requestAnimationFrame(this.loopBind);
      }
      se(name) {
        let a = document.getElementById(name);
        if (a) { a.currentTime = 0; a.play().catch(() => { }); }
      }
      finish(reason) {
        this.state = "result";
        isPlaying = false;
        document.getElementById("virtualPad").style.display = "none";
        let winnerText, reasonText = reason || "";
        if (reason && reason.includes("CPUがミス")) {
          winnerText = "あなたの勝ち！";
        } else if (reason && reason.includes("あなたがミス")) {
          winnerText = "CPUの勝ち";
        } else {
          let pscore = 0, cscore = 0;
          for (let bl of this.blocks) {
            if (bl.owner === 0) pscore++;
            else if (bl.owner === 1) cscore++;
          }
          winnerText = pscore > cscore ? "あなたの勝ち！" : (pscore < cscore ? "CPUの勝ち" : "引き分け！");
        }
        document.getElementById("result").style.display = "flex";
        document.getElementById("winner").textContent = winnerText;
        document.getElementById("reason").textContent = reasonText;
        this.se("win");
      }
      render() {
        const ctx = this.ctx, s = this.canvas.width / GRID;
        ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
        ctx.fillStyle = BG;
        ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);
        for (let bl of this.blocks) {
          ctx.save();
          ctx.globalAlpha = 1;
          ctx.fillStyle = bl.color();
          if (bl.y === GRID / 2 - 1 || bl.y === GRID / 2) {
            ctx.strokeStyle = "#FFF";
            ctx.lineWidth = 3;
          } else {
            ctx.strokeStyle = "#444";
            ctx.lineWidth = 1.1;
          }
          ctx.beginPath();
          ctx.rect((bl.x + 0.03) * s, (bl.y + 0.03) * s, s * 0.93, s * 0.93);
          ctx.fill();
          ctx.stroke();
          ctx.restore();
        }
        for (let pid = 0; pid < 2; pid++) {
          let p = this.paddles[pid];
          ctx.save();
          ctx.fillStyle = "#FFFFFF";
          ctx.shadowColor = pid ? "#FF2080" : "#00FFD0";
          ctx.shadowBlur = 13;
          ctx.beginPath();
          ctx.roundRect((p.x - PADDLE_WIDTH / 2) * s, (p.y - 0.18) * s, s * PADDLE_WIDTH, s * 0.44, s * 0.18);
          ctx.fill();
          ctx.restore();
        }
        for (let pid = 0; pid < 2; pid++) {
          let b = this.balls[pid];
          ctx.save();
          ctx.beginPath();
          ctx.arc(b.x * s, b.y * s, s * BALL_R, 0, 2 * Math.PI);
          ctx.fillStyle = "#FFFFFF";
          ctx.shadowColor = pid ? "#FF2080" : "#00FFD0";
          ctx.shadowBlur = 20;
          ctx.globalAlpha = 0.95;
          ctx.fill();
          ctx.restore();
        }
        let pscore = 0, cscore = 0;
        for (let bl of this.blocks) {
          if (bl.owner === 0) pscore++;
          else if (bl.owner === 1) cscore++;
        }
        document.querySelector(".hud-player").textContent = `あなた: ${pscore}`;
        document.querySelector(".hud-cpu").textContent = `CPU: ${cscore}`;
        document.querySelector(".hud-player").insertAdjacentHTML('afterbegin', '<span class="arrow">&#x25BC;</span>');
        document.querySelector(".hud-cpu").insertAdjacentHTML('beforeend', '<span class="arrow">&#x25B2;</span>');
      }
    }

    // ゲーム進行フロー
    let g;
    function startCountdownThenPlay() {
      const cd = document.getElementById("countdown");
      const start = document.getElementById("start");
      const result = document.getElementById("result");
      start.style.display = "none"; result.style.display = "none";
      cd.style.display = "flex";
      let count = 3;
      const countNum = document.getElementById("count-number");
      countNum.textContent = count;
      let countdownSE = () => {
        let a = document.getElementById("startSE");
        if (a) { a.currentTime = 0; a.play().catch(() => { }); }
      }
      countdownSE();
      let interval = setInterval(() => {
        count--;
        if (count > 0) {
          countNum.textContent = count;
          countdownSE();
        } else if (count === 0) {
          countNum.textContent = "START!";
          countdownSE();
        } else {
          clearInterval(interval);
          cd.style.display = "none";
          g = new Game();
          setupVirtualPad(g);
          setTimeout(() => g.start(), 100);
        }
      }, 800);
    }
    document.getElementById("playbtn").onclick = startCountdownThenPlay;

    // バーチャルパッド
    function setupVirtualPad(gameInstance) {
      const pad = document.getElementById("virtualPad");
      const padInner = document.getElementById("padInner");
      if (!pad || !padInner) return;
      let padActive = false, padStartX = 0, lastMove = 0;
      const PAD_SENSITIVITY = 0.048;
      function resetPadVisual() {
        padInner.style.transition = "transform 0.17s";
        padInner.style.transform = "translateX(0px)";
        pad.classList.remove("active");
      }
      pad.onpointerdown = function (e) {
        if (!gameInstance || gameInstance.state !== "playing") return;
        padActive = true; pad.classList.add("active");
        pad.setPointerCapture(e.pointerId);
        padStartX = e.clientX; padInner.style.transition = "none"; lastMove = 0;
      };
      pad.onpointermove = function (e) {
        if (!padActive || !gameInstance || gameInstance.state !== "playing") return;
        const deltaX = e.clientX - padStartX;
        padInner.style.transform = `translateX(${Math.max(-36, Math.min(36, deltaX))}px)`;
        if (Math.abs(deltaX - lastMove) > 5) {
          gameInstance.paddles[0].moveTo(gameInstance.paddles[0].x + (deltaX - lastMove) * PAD_SENSITIVITY);
          lastMove = deltaX;
        }
      };
      pad.onpointerup = function (e) {
        padActive = false; resetPadVisual(); pad.releasePointerCapture(e.pointerId);
      };
      pad.onpointerleave = function (e) {
        padActive = false; resetPadVisual(); pad.releasePointerCapture(e.pointerId);
      };
    }
  </script>
</body>

</html>
