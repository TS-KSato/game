<!doctype html>
<html lang="ja">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Line Puzzle Pro – Stable</title>

<!-- CDN + ローカル fallback (同フォルダに pixi.8.9.2.min.js を置く) -->
<script src="https://cdnjs.cloudflare.com/ajax/libs/pixi.js/8.9.2/pixi.min.js"
        integrity="sha512-w9uF0PNgAxE/ZGpZZnwXj1o19sX1oKIQMVmn1z6s+s88tKksMuBX1IUOwN+31Li6CTQ0BNgHh655kD8uOz2cqw=="
        crossorigin="anonymous"
        onerror="this.onerror=null;this.remove();"></script>
<script src="pixi.min.js"></script>

<style>
:root{ --node:#43a4ff; --edge:#7b93ad; --edgeOn:#43a4ff; --accent:#ffbf3c }
html,body{margin:0;height:100%;display:flex;flex-direction:column;background:#f4f7fb;font-family:sans-serif}
header{height:56px;display:flex;justify-content:center;align-items:center;background:#fff8;backdrop-filter:blur(6px);box-shadow:0 3px 8px #0002}
h1{margin:0;font-size:16px;font-weight:700}
#stage{flex:1;display:flex;justify-content:center;align-items:center;overflow:hidden;position:relative}
#ui{display:flex;gap:.6rem;padding:10px;background:#fff8;backdrop-filter:blur(6px)}
#ui button{flex:1;border:none;padding:12px 0;border-radius:14px;background:#fff;font-weight:700;box-shadow:0 3px 6px #0002;cursor:pointer}
#ui button:active{transform:scale(.96)}
#overlay{position:absolute;inset:0;display:flex;justify-content:center;align-items:center;
         background:#fff8;font-size:18px;backdrop-filter:blur(2px)}
canvas{touch-action:none}
</style>
</head>
<body>
<header><h1>Line Puzzle Pro</h1></header>

<div id="stage"><div id="overlay">Loading…</div></div>

<div id="ui">
  <button id="resetBtn">Reset</button>
  <button id="hintBtn">Hint</button>
</div>

<script>
(async () => {
  const stage   = document.getElementById('stage');
  const overlay = document.getElementById('overlay');

  /* --- Pixi が読み込めたか --- */
  if (typeof PIXI === 'undefined') {
    overlay.textContent = 'Pixi を読み込めませんでした';
    return;
  }

  /* --- Application 初期化 --- */
  const app = new PIXI.Application();
  await app.init({
    width: 1, height: 1,
    backgroundAlpha: 0,
    antialias: true,
    preferEnvironment: 'auto'
  });
  stage.appendChild(app.canvas);

  /* --- データ読込 --- */
  let puzzles;
  try {
    puzzles = (await (await fetch('contents.json')).json()).puzzles;
  } catch (e) {
    overlay.textContent='puzzles 読込失敗';
    console.error(e);
    return;
  }

  /* ---------- 状態管理クラス ---------- */
  class State {
    cur=null; traced=new Set(); path=[]; invalid=true;
    load(level){ this.cur=puzzles.find(p=>p.difficulty===level);
                 this.traced.clear(); this.path.length=0; this.invalidate(); }
    invalidate(){ this.invalid=true; if (!app.ticker.started) app.ticker.start(); }
  }
  const st = new State();

  /* ---------- Graphics ---------- */
  const gE=new PIXI.Graphics(), gN=new PIXI.Graphics();
  app.stage.addChild(gE,gN);

  /* ---------- レイアウト ---------- */
  const R=22;
  function fit(){
    const s=Math.max(1,Math.min(stage.clientWidth,stage.clientHeight));
    app.renderer.resize(s,s); st.invalidate();
  }
  window.addEventListener('resize',fit);

  /* ---------- 入力 ---------- */
  const hit=(x,y)=>{
    const {width:W,height:H}=app.renderer, thr=R*1.2*(W/800);
    return st.cur.nodes.findIndex(n=>Math.hypot(n.x*W-x,n.y*H-y)<=thr);
  };
  const edgeIdx=(a,b)=>st.cur.edges.findIndex(e=>(e.from===a&&e.to===b)||(e.from===b&&e.to===a));

  app.stage.eventMode='static';
  app.stage.on('pointerdown',e=>{
    const {x,y}=e.global, idx=hit(x,y);
    if(idx!==-1){ st.path=[idx]; st.invalidate(); }
  });
  app.stage.on('pointermove',e=>{
    if(!st.path.length) return;
    const {x,y}=e.global, idx=hit(x,y);
    if(idx!==-1 && idx!==st.path.at(-1)){
      const i=edgeIdx(st.path.at(-1),idx);
      if(i!==-1 && !st.traced.has(i)){ st.traced.add(i); st.path.push(idx); st.invalidate(); }
    }
  });

  /* ---------- 描画 ---------- */
  app.ticker.autoStart=false;
  app.ticker.add(()=>{
    if(!st.invalid) { app.ticker.stop(); return; }
    st.invalid=false;
    const {width:W,height:H}=app.renderer, r=R*(W/800);
    gE.clear(); gN.clear();

    // 未トレース
    gE.lineStyle({width:r*.5,color:0x7b93ad,cap:'round'});
    st.cur.edges.forEach(e=>{
      const a=st.cur.nodes[e.from],b=st.cur.nodes[e.to];
      gE.moveTo(a.x*W,a.y*H).lineTo(b.x*W,b.y*H);
    });
    // トレース済
    gE.lineStyle({width:r*.65,color:0x43a4ff,cap:'round'});
    st.traced.forEach(i=>{
      const e=st.cur.edges[i],a=st.cur.nodes[e.from],b=st.cur.nodes[e.to];
      gE.moveTo(a.x*W,a.y*H).lineTo(b.x*W,b.y*H);
    });
    // ノード
    st.cur.nodes.forEach((n,i)=>{
      const col=(st.path.at(-1)===i)?0xffbf3c:0x43a4ff;
      gN.beginFill(col).drawCircle(n.x*W,n.y*H,r).endFill();
    });
  });

  /* ---------- UI ---------- */
  document.getElementById('resetBtn').onclick=()=>{
    st.traced.clear(); st.path.length=0; st.invalidate();
  };
  document.getElementById('hintBtn').onclick=()=>{
    const i=st.cur.edges.findIndex((_,idx)=>!st.traced.has(idx));
    if(i!==-1){ st.path=[st.cur.edges[i].from]; st.invalidate(); }
  };

  /* ---------- 最初のロード & レイアウト ---------- */
  st.load(1);
  fit();
  overlay.style.display='none';
})();
</script>
</body>
</html>
