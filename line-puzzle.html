<!doctype html>
<html lang="ja">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width,initial-scale=1">
<title>Line Puzzle Pro WebGL</title>
<link href="https://fonts.googleapis.com/css2?family=Inter:wght@500;700&display=swap" rel="stylesheet">
<script src="https://cdn.jsdelivr.net/npm/pixi.js@8.x/dist/pixi.min.js"></script>
<style>
:root{
  --bg:#f4f7fb;
  --node:#43a4ff;
  --edge:#7b93ad;
  --edge-on:#43a4ff;
  --accent:#ffbf3c;
  --radius:14px;
  font-family:"Inter",system-ui,sans-serif;
}
html,body{height:100%;margin:0;background:var(--bg);color:#1e293b}
#wrap{display:flex;flex-direction:column;height:100%}
header{display:flex;justify-content:center;align-items:center;height:56px;
  backdrop-filter:blur(8px);background:rgba(255,255,255,.8);box-shadow:0 4px 12px rgba(0,0,0,.1)}
h1{margin:0;font-size:1rem;font-weight:700}
#stage{flex:1;display:flex;justify-content:center;align-items:center;overflow:hidden}
#ui{display:flex;gap:.6rem;padding:10px;background:rgba(255,255,255,.8);backdrop-filter:blur(8px)}
#ui button{flex:1;border:none;padding:12px 0;border-radius:var(--radius);font-weight:700;
  background:#fff;box-shadow:0 4px 8px rgba(0,0,0,.1);cursor:pointer}
#ui button:active{transform:scale(.96)}
canvas{touch-action:none}
</style>
</head>
<body>
<div id="wrap">
  <header><h1>Line Puzzle Pro</h1></header>
  <div id="stage"></div>
  <div id="ui">
    <button id="resetBtn">Reset</button>
    <button id="hintBtn">Hint</button>
  </div>
</div>

<script>
/* ------------ Pixi アプリ初期化 ------------ */
const STAGE = document.getElementById('stage');
const app = new PIXI.Application({resizeTo: STAGE, antialias:true, backgroundAlpha:0});
STAGE.appendChild(app.view);

/* ------------ レンダリング用コンテナ ------------ */
const gEdges = new PIXI.Graphics();
const gNodes = new PIXI.Graphics();
app.stage.addChild(gEdges, gNodes);

/* ------------ 状態変数 ------------ */
let puzzles=[], cur=null, traced=new Set(), path=[];
const R_NODE_BASE = 22;          // 基準ノード半径 (px)

/* ------------ 正方形フィッティング ------------ */
function layout(){
  const S = Math.min(STAGE.clientWidth, STAGE.clientHeight);
  app.renderer.resize(S, S);
  draw();
}
window.addEventListener('resize',layout);

/* ------------ JSON 読込 ------------ */
fetch('puzzles.json')
  .then(r=>r.json())
  .then(d=>{puzzles=d.puzzles;load(1);layout();});

/* ------------ ロード & リセット ------------ */
function load(level){
  cur = puzzles.find(p=>p.difficulty==level);
  traced.clear(); path.length=0; draw();
}

/* ------------ 描画 ------------ */
function draw(){
  if(!cur) return;
  const W = app.renderer.width, H = app.renderer.height;
  const rNode = R_NODE_BASE * (W/800);   // 画面幅に比例してノード半径可変

  gEdges.clear();
  gNodes.clear();

  /* edges */
  gEdges.lineStyle({width:rNode*0.55, color:PIXI.utils.string2hex(getComputedStyle(document.documentElement).getPropertyValue('--edge')), cap:'round'});
  cur.edges.forEach((e,i)=>{
    const A=cur.nodes[e.from], B=cur.nodes[e.to];
    gEdges.moveTo(A.x*W, A.y*H).lineTo(B.x*W, B.y*H);
  });
  /* traced highlight 上書き */
  gEdges.lineStyle({width:rNode*0.7, color:PIXI.utils.string2hex(getComputedStyle(document.documentElement).getPropertyValue('--edge-on')), cap:'round'});
  traced.forEach(i=>{
    const e=cur.edges[i], A=cur.nodes[e.from], B=cur.nodes[e.to];
    gEdges.moveTo(A.x*W, A.y*H).lineTo(B.x*W, B.y*H);
  });

  /* nodes */
  cur.nodes.forEach((n,idx)=>{
    const c = (path[path.length-1]===idx) ? PIXI.utils.string2hex(getComputedStyle(document.documentElement).getPropertyValue('--accent')) :
                                            PIXI.utils.string2hex(getComputedStyle(document.documentElement).getPropertyValue('--node'));
    gNodes.beginFill(c).drawCircle(n.x*W, n.y*H, rNode).endFill();
  });
}

/* ------------ 入力 (pointer) ------------ */
app.stage.eventMode='static';
app.stage.on('pointerdown',onDown).on('pointermove',onMove);
function toIdx(px,py){
  const W=app.renderer.width,H=app.renderer.height;
  return cur.nodes.findIndex(n=>Math.hypot(n.x*W-px,n.y*H-py)<=R_NODE_BASE*1.2*(W/800));
}
function edgeIdx(a,b){
  return cur.edges.findIndex(e=> (e.from===a&&e.to===b)||(e.from===b&&e.to===a));
}
function connect(a,b){
  const idx=edgeIdx(a,b);
  if(idx===-1||traced.has(idx)) return false;
  traced.add(idx); path.push(b);
  draw(); return true;
}
function onDown(e){
  const p=e.data.global, i=toIdx(p.x,p.y);
  if(i!==-1){path=[i];draw();}
}
function onMove(e){
  if(!path.length) return;
  const p=e.data.global, i=toIdx(p.x,p.y);
  if(i!==-1 && i!==path[path.length-1]) connect(path[path.length-1],i);
}

/* ------------ UI ボタン ------------ */
document.getElementById('resetBtn').onclick=()=>load(cur.difficulty);
document.getElementById('hintBtn').onclick=()=>{
  const idx=cur.edges.findIndex((_,i)=>!traced.has(i));
  if(idx===-1) return;
  const {from}=cur.edges[idx]; path=[from]; draw();
};
</script>
</body>
</html>
