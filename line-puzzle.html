<!doctype html>
<html lang="ja">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width,initial-scale=1">
<title>Line Puzzle Pro WebGL</title>
<link href="https://fonts.googleapis.com/css2?family=Inter:wght@500;700&display=swap" rel="stylesheet">
<script src="pixi.min.js"></script>
<script src="pixi.js"></script>
<style>
:root{
  --bg:#f4f7fb;
  --node:#43a4ff;
  --edge:#7b93ad;
  --edge-on:#43a4ff;
  --accent:#ffbf3c;
  --radius:14px;
  font-family:"Inter",system-ui,sans-serif;
}
html,body{margin:0;height:100%;display:flex;flex-direction:column;font-family:sans-serif}
#stage{flex:1;display:flex;justify-content:center;align-items:center;overflow:hidden;background:#f4f7fb}
canvas{touch-action:none}
#wrap{display:flex;flex-direction:column;height:100%}
header{display:flex;justify-content:center;align-items:center;height:56px;
  backdrop-filter:blur(8px);background:rgba(255,255,255,.8);box-shadow:0 4px 12px rgba(0,0,0,.1)}
h1{margin:0;font-size:1rem;font-weight:700}
#ui{display:flex;gap:.6rem;padding:10px;background:rgba(255,255,255,.8);backdrop-filter:blur(8px)}
#ui button{flex:1;border:none;padding:12px 0;border-radius:var(--radius);font-weight:700;
  background:#fff;box-shadow:0 4px 8px rgba(0,0,0,.1);cursor:pointer}
#ui button:active{transform:scale(.96)}
</style>
</head>
<body>
<div id="wrap">
  <header><h1>Line Puzzle Pro</h1></header>
  <div id="stage"></div>
  <div id="ui">
    <button id="resetBtn">Reset</button>
    <button id="hintBtn">Hint</button>
  </div>
</div>

<script>
// グローバル変数の宣言
const STAGE_ELEMENT = document.getElementById('stage');
let puzzles = [];
let currentPuzzle = null;
const tracedEdges = new Set();
let currentPath = [];

// PIXI Graphics Objects
const gEdges = new PIXI.Graphics();
const gNodes = new PIXI.Graphics();
const gTestBounds = new PIXI.Graphics();

// 定数
const NODE_BASE_RADIUS = 20;
const NODE_HIT_RADIUS_SCALE_FACTOR = 1.2;
const BASE_CANVAS_WIDTH_FOR_SCALING = 800;

// CSSカラーのキャッシュ用オブジェクト
let appColors = {
    edge: 0x7b93ad,
    edgeOn: 0x43a4ff,
    node: 0x43a4ff,
    accent: 0xffbf3c,
};

// Pixi Application 初期化
let app;
try {
  app = new PIXI.Application({
    width: 1,
    height: 1,
    backgroundAlpha: 0,
    antialias: true,
    forceCanvas: true, // ★変更点: WebGLに問題がある場合に備え、Canvas 2Dレンダラーを強制的に使用
  });
} catch (e) {
  STAGE_ELEMENT.textContent = 'Pixi Applicationの作成中にエラーが発生しました: ' + e.message;
  console.error('Error creating PIXI.Application:', e);
  throw e; // エラーを再スローしてスクリプトを停止
}


// Renderer初期化チェック
if (!app || !app.renderer) {
  STAGE_ELEMENT.textContent = 'Pixi Renderer の初期化に失敗しました。お使いのブラウザがCanvas 2Dをサポートしているか、またはPixiJSライブラリ (`pixi.min.js`) が正しく読み込まれ、互換性のあるバージョンであるか確認してください。';
  console.error('Pixi Renderer initialization failed. PIXI object:', PIXI, 'App object:', app);
  throw new Error('Renderer init failed');
}

// DOMにCanvasを追加
// forceCanvas: true のため、app.view が使われることを期待 (多くのPixiJSバージョンで)
// PixiJS v8+ など新しいバージョンでは app.canvas の場合もあります。
if (app.view instanceof HTMLCanvasElement) {
    STAGE_ELEMENT.appendChild(app.view);
} else if (app.canvas instanceof HTMLCanvasElement) {
    STAGE_ELEMENT.appendChild(app.canvas);
} else {
    STAGE_ELEMENT.textContent = 'Pixi Canvas要素 (app.view / app.canvas) が見つかりません。PixiJSのバージョンと読み込み状態を確認してください。';
    console.error('Pixi canvas element not found. app.view:', app.view, 'app.canvas:', app.canvas);
    throw new Error('Pixi canvas element not found.');
}


// CSSから色を読み込んでキャッシュする関数
function cacheCssColors() {
  const styles = getComputedStyle(document.documentElement);
  try {
    appColors.edge = PIXI.utils.string2hex(styles.getPropertyValue('--edge'));
    appColors.edgeOn = PIXI.utils.string2hex(styles.getPropertyValue('--edge-on'));
    appColors.node = PIXI.utils.string2hex(styles.getPropertyValue('--node'));
    appColors.accent = PIXI.utils.string2hex(styles.getPropertyValue('--accent'));
  } catch (e) {
    console.warn("CSSカスタムプロパティからの色の読み込みに失敗しました。デフォルト色を使用します。", e);
    // フォールバックとしてデフォルト値を維持
  }
}

/* ========== 正方形リサイズ ========== */
function resizeSquare() {
  const s = Math.max(1, Math.min(STAGE_ELEMENT.clientWidth, STAGE_ELEMENT.clientHeight));
  if (app && app.renderer) {
    app.renderer.resize(s, s);
    if (currentPuzzle) {
      draw();
    }
    // drawTestBounds(); // 必要に応じてテスト境界も再描画
  }
}

/* ------------ 描画 ------------ */
function draw(){
  if(!currentPuzzle || !app || !app.renderer) return;

  const W = app.renderer.width;
  const H = app.renderer.height;
  const nodeRadius = NODE_BASE_RADIUS * (W / BASE_CANVAS_WIDTH_FOR_SCALING);

  gEdges.clear();
  gNodes.clear();

  /* edges */
  gEdges.lineStyle({width: nodeRadius * 0.55, color: appColors.edge, cap: 'round'});
  currentPuzzle.edges.forEach((edge) => {
    const nodeA = currentPuzzle.nodes[edge.from];
    const nodeB = currentPuzzle.nodes[edge.to];
    gEdges.moveTo(nodeA.x * W, nodeA.y * H).lineTo(nodeB.x * W, nodeB.y * H);
  });

  /* traced highlight 上書き */
  if (tracedEdges.size > 0) {
    gEdges.lineStyle({width: nodeRadius * 0.7, color: appColors.edgeOn, cap: 'round'});
    tracedEdges.forEach(edgeIndex => {
      const edge = currentPuzzle.edges[edgeIndex];
      const nodeA = currentPuzzle.nodes[edge.from];
      const nodeB = currentPuzzle.nodes[edge.to];
      gEdges.moveTo(nodeA.x * W, nodeA.y * H).lineTo(nodeB.x * W, nodeB.y * H);
    });
  }

  /* nodes */
  currentPuzzle.nodes.forEach((n, idx) => {
    const color = (currentPath.length > 0 && currentPath[currentPath.length - 1] === idx) ? appColors.accent : appColors.node;
    gNodes.beginFill(color).drawCircle(n.x * W, n.y * H, nodeRadius).endFill();
  });
}

/* ========== テスト図形 (青枠) ========== */
function drawTestBounds() {
  if (!app || !app.renderer) return;
  gTestBounds.clear();
  gTestBounds.lineStyle({ width: 6, color: 0x3498db, cap: 'round' })
   .drawPolygon([20,20 , app.renderer.width-20,20 , app.renderer.width-20,app.renderer.height-20 , 20,app.renderer.height-20 , 20,20]);
}


/* ------------ ロード & リセット ------------ */
function loadPuzzle(level){
  const puzzleData = puzzles.find(p => p.difficulty == level);
  if (!puzzleData) {
    console.error(`Puzzle for level ${level} not found.`);
    return;
  }
  currentPuzzle = puzzleData;
  tracedEdges.clear();
  currentPath.length = 0;
  draw();
}

/* ------------ 入力 (pointer) イベントハンドラ ------------ */
function getTouchedNodeIndex(pointerX, pointerY){
  if (!currentPuzzle || !app || !app.renderer) return -1;
  const W = app.renderer.width;
  const H = app.renderer.height;
  const nodeRadius = NODE_BASE_RADIUS * (W / BASE_CANVAS_WIDTH_FOR_SCALING);
  const hitRadius = nodeRadius * NODE_HIT_RADIUS_SCALE_FACTOR;

  return currentPuzzle.nodes.findIndex(node =>
    Math.hypot(node.x * W - pointerX, node.y * H - pointerY) <= hitRadius
  );
}

function getEdgeIndex(nodeAIndex, nodeBIndex){
  if (!currentPuzzle) return -1;
  return currentPuzzle.edges.findIndex(edge =>
    (edge.from === nodeAIndex && edge.to === nodeBIndex) ||
    (edge.from === nodeBIndex && edge.to === nodeAIndex)
  );
}

function connectNodes(nodeAIndex, nodeBIndex){
  const edgeIndex = getEdgeIndex(nodeAIndex, nodeBIndex);
  if(edgeIndex === -1 || tracedEdges.has(edgeIndex)) return false;

  tracedEdges.add(edgeIndex);
  currentPath.push(nodeBIndex);
  draw();
  return true;
}

function onPointerDown(event){
  if (!currentPuzzle || !app || !app.stage) return;
  const localPos = event.data.getLocalPosition(app.stage);
  const touchedNodeIdx = getTouchedNodeIndex(localPos.x, localPos.y);

  if(touchedNodeIdx !== -1){
    currentPath = [touchedNodeIdx];
    tracedEdges.clear();
    draw();
  }
}

function onPointerMove(event){
  if (!currentPuzzle || currentPath.length === 0 || !app || !app.stage) return;

  const localPos = event.data.getLocalPosition(app.stage);
  const touchedNodeIdx = getTouchedNodeIndex(localPos.x, localPos.y);
  const lastNodeInPath = currentPath[currentPath.length - 1];

  if(touchedNodeIdx !== -1 && touchedNodeIdx !== lastNodeInPath) {
    connectNodes(lastNodeInPath, touchedNodeIdx);
  }
}

// 初期化処理
function initializeGame() {
  if (!app || !app.stage) {
      console.error("Pixi Application または Stage が初期化されていません。");
      return;
  }
  app.stage.addChild(gEdges);
  app.stage.addChild(gNodes);
  app.stage.addChild(gTestBounds);

  cacheCssColors();

  window.addEventListener('resize', resizeSquare);
  resizeSquare();

  app.stage.eventMode = 'static';
  app.stage.interactive = true; // 念のため古いバージョンとの互換性
  app.stage.on('pointerdown', onPointerDown);
  app.stage.on('pointermove', onPointerMove);

  fetch('contents.json')
    .then(response => {
      if (!response.ok) {
        throw new Error(`HTTP error! status: ${response.status} while fetching contents.json`);
      }
      return response.json();
    })
    .then(data => {
      puzzles = data.puzzles;
      if (puzzles && puzzles.length > 0) {
        loadPuzzle(1);
        // drawTestBounds(); // 初期描画
      } else {
        console.error("No puzzles found in contents.json or data is malformed.");
        STAGE_ELEMENT.textContent = 'パズルデータの読み込みに失敗しました。contents.jsonを確認してください。';
      }
    })
    .catch(error => {
      console.error('Failed to load or process contents.json:', error);
      STAGE_ELEMENT.textContent = `エラー: ${error.message}`;
    });

  document.getElementById('resetBtn').onclick = () => {
    if (currentPuzzle) {
      loadPuzzle(currentPuzzle.difficulty);
    }
  };

  document.getElementById('hintBtn').onclick = () => {
    if (!currentPuzzle) return;
    const unsolvedEdgeIndex = currentPuzzle.edges.findIndex((_, i) => !tracedEdges.has(i));
    if(unsolvedEdgeIndex === -1) return;

    const hintEdge = currentPuzzle.edges[unsolvedEdgeIndex];
    currentPath = [hintEdge.from];
    tracedEdges.clear();
    // Optional: もしヒントで示されたエッジをトレース済みにするなら:
    // tracedEdges.add(unsolvedEdgeIndex);
    // currentPath.push(hintEdge.to);
    draw();
  };
}

// ゲーム初期化を実行 (DOMが完全に読み込まれてからの方が安全な場合もあるが、ここではscriptがbody末尾なので即時実行)
initializeGame();

</script>
</body>
</html>
