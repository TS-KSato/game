<!doctype html>
<html lang="ja">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width,initial-scale=1">
<title>Line Puzzle Pro WebGL</title>
<link href="https://fonts.googleapis.com/css2?family=Inter:wght@500;700&display=swap" rel="stylesheet">
<script src="pixi.js"></script>
<style>
:root{
  --bg:#f4f7fb;
  --node:#43a4ff;
  --edge:#7b93ad;
  --edge-on:#43a4ff;
  --accent:#ffbf3c;
  --radius:14px;
  font-family:"Inter",system-ui,sans-serif;
}
html,body{margin:0;height:100%;display:flex;flex-direction:column;font-family:sans-serif}
#stage{flex:1;display:flex;justify-content:center;align-items:center;overflow:hidden;background:#f4f7fb}
canvas{touch-action:none}
#wrap{display:flex;flex-direction:column;height:100%}
header{display:flex;justify-content:center;align-items:center;height:56px;
  backdrop-filter:blur(8px);background:rgba(255,255,255,.8);box-shadow:0 4px 12px rgba(0,0,0,.1)}
h1{margin:0;font-size:1rem;font-weight:700}
#ui{display:flex;gap:.6rem;padding:10px;background:rgba(255,255,255,.8);backdrop-filter:blur(8px)}
#ui button{flex:1;border:none;padding:12px 0;border-radius:var(--radius);font-weight:700;
  background:#fff;box-shadow:0 4px 8px rgba(0,0,0,.1);cursor:pointer}
#ui button:active{transform:scale(.96)}
</style>
</head>
<body>
<div id="wrap">
  <header><h1>Line Puzzle Pro</h1></header>
  <div id="stage"></div>
  <div id="ui">
    <button id="resetBtn">Reset</button>
    <button id="hintBtn">Hint</button>
  </div>
</div>

<script>
// グローバル変数の宣言
const STAGE_ELEMENT = document.getElementById('stage');
let puzzles = [];
let currentPuzzle = null;
const tracedEdges = new Set();
let currentPath = [];

// PIXI Graphics Objects
const gEdges = new PIXI.Graphics();
const gNodes = new PIXI.Graphics();
const gTestBounds = new PIXI.Graphics(); // 元の 'g' (テスト図形)

// 定数
const NODE_BASE_RADIUS = 20;
const NODE_HIT_RADIUS_SCALE_FACTOR = 1.2;
const BASE_CANVAS_WIDTH_FOR_SCALING = 800;

// CSSカラーのキャッシュ用オブジェクト
let appColors = {
    edge: 0x7b93ad,
    edgeOn: 0x43a4ff,
    node: 0x43a4ff,
    accent: 0xffbf3c,
};

// Pixi Application
let app;


// CSSから色を読み込んでキャッシュする関数
function cacheCssColors() {
  const styles = getComputedStyle(document.documentElement);
  try {
    appColors.edge = PIXI.utils.string2hex(styles.getPropertyValue('--edge'));
    appColors.edgeOn = PIXI.utils.string2hex(styles.getPropertyValue('--edge-on'));
    appColors.node = PIXI.utils.string2hex(styles.getPropertyValue('--node'));
    appColors.accent = PIXI.utils.string2hex(styles.getPropertyValue('--accent'));
  } catch (e) {
    console.warn("CSSカスタムプロパティからの色の読み込みに失敗しました。デフォルト色を使用します。", e);
  }
}

/* ========== 正方形リサイズ ========== */
function resizeSquare() {
  const s = Math.max(1, Math.min(STAGE_ELEMENT.clientWidth, STAGE_ELEMENT.clientHeight));
  if (app && app.renderer) {
    app.renderer.resize(s, s);
    if (currentPuzzle) {
      draw();
    }
    // drawTestBounds(); // 必要に応じてテスト境界も再描画
  }
}

/* ------------ 描画 ------------ */
function draw(){
  if(!currentPuzzle || !app || !app.renderer) return;

  const W = app.renderer.width;
  const H = app.renderer.height;
  const nodeRadius = NODE_BASE_RADIUS * (W / BASE_CANVAS_WIDTH_FOR_SCALING);

  gEdges.clear();
  gNodes.clear();

  /* edges */
  gEdges.lineStyle({width: nodeRadius * 0.55, color: appColors.edge, cap: 'round'});
  currentPuzzle.edges.forEach((edge) => {
    const nodeA = currentPuzzle.nodes[edge.from];
    const nodeB = currentPuzzle.nodes[edge.to];
    gEdges.moveTo(nodeA.x * W, nodeA.y * H).lineTo(nodeB.x * W, nodeB.y * H);
  });

  /* traced highlight 上書き */
  if (tracedEdges.size > 0) {
    gEdges.lineStyle({width: nodeRadius * 0.7, color: appColors.edgeOn, cap: 'round'});
    tracedEdges.forEach(edgeIndex => {
      const edge = currentPuzzle.edges[edgeIndex];
      const nodeA = currentPuzzle.nodes[edge.from];
      const nodeB = currentPuzzle.nodes[edge.to];
      gEdges.moveTo(nodeA.x * W, nodeA.y * H).lineTo(nodeB.x * W, nodeB.y * H);
    });
  }

  /* nodes */
  currentPuzzle.nodes.forEach((n, idx) => {
    const color = (currentPath.length > 0 && currentPath[currentPath.length - 1] === idx) ? appColors.accent : appColors.node;
    gNodes.beginFill(color).drawCircle(n.x * W, n.y * H, nodeRadius).endFill();
  });
}

/* ========== テスト図形 (青枠) ========== */
function drawTestBounds() {
  if (!app || !app.renderer) return;
  gTestBounds.clear();
  gTestBounds.lineStyle({ width: 6, color: 0x3498db, cap: 'round' })
   .drawPolygon([20,20 , app.renderer.width-20,20 , app.renderer.width-20,app.renderer.height-20 , 20,app.renderer.height-20 , 20,20]);
}


/* ------------ ロード & リセット ------------ */
function loadPuzzle(level){
  const puzzleData = puzzles.find(p => p.difficulty == level);
  if (!puzzleData) {
    console.error(`Puzzle for level ${level} not found.`);
    return;
  }
  currentPuzzle = puzzleData;
  tracedEdges.clear();
  currentPath.length = 0;
  draw();
}

/* ------------ 入力 (pointer) イベントハンドラ ------------ */
function getTouchedNodeIndex(pointerX, pointerY){
  if (!currentPuzzle || !app || !app.renderer) return -1;
  const W = app.renderer.width;
  const H = app.renderer.height;
  const nodeRadius = NODE_BASE_RADIUS * (W / BASE_CANVAS_WIDTH_FOR_SCALING);
  const hitRadius = nodeRadius * NODE_HIT_RADIUS_SCALE_FACTOR;

  return currentPuzzle.nodes.findIndex(node =>
    Math.hypot(node.x * W - pointerX, node.y * H - pointerY) <= hitRadius
  );
}

function getEdgeIndex(nodeAIndex, nodeBIndex){
  if (!currentPuzzle) return -1;
  return currentPuzzle.edges.findIndex(edge =>
    (edge.from === nodeAIndex && edge.to === nodeBIndex) ||
    (edge.from === nodeBIndex && edge.to === nodeAIndex)
  );
}

function connectNodes(nodeAIndex, nodeBIndex){
  const edgeIndex = getEdgeIndex(nodeAIndex, nodeBIndex);
  if(edgeIndex === -1 || tracedEdges.has(edgeIndex)) return false;

  tracedEdges.add(edgeIndex);
  currentPath.push(nodeBIndex);
  draw();
  return true;
}

function onPointerDown(event){
  if (!currentPuzzle || !app || !app.stage) return;
  const localPos = event.data.getLocalPosition(app.stage); // v8ではevent.dataは不要、event.getLocalPosition(app.stage)
  const touchedNodeIdx = getTouchedNodeIndex(localPos.x, localPos.y);

  if(touchedNodeIdx !== -1){
    currentPath = [touchedNodeIdx];
    tracedEdges.clear();
    draw();
  }
}

function onPointerMove(event){
  if (!currentPuzzle || currentPath.length === 0 || !app || !app.stage) return;

  const localPos = event.getLocalPosition(app.stage); // v8ではevent.dataは不要
  const touchedNodeIdx = getTouchedNodeIndex(localPos.x, localPos.y);
  const lastNodeInPath = currentPath[currentPath.length - 1];

  if(touchedNodeIdx !== -1 && touchedNodeIdx !== lastNodeInPath) {
    connectNodes(lastNodeInPath, touchedNodeIdx);
  }
}

// 非同期初期化処理
async function initializeGame() {
  // PixiJS v8 style initialization
  app = new PIXI.Application();

  try {
    await app.init({
        width: 1, // 初期サイズはリサイズ時に調整
        height: 1,
        backgroundAlpha: 0, // HTMLの背景を透過
        antialias: true,
        preference: 'webgl', // WebGLを優先
        // autoStart: false, // Tickerを自分で管理する場合。デフォルトはtrue
    });
  } catch (e) {
      STAGE_ELEMENT.textContent = 'Pixi Application の初期化に失敗しました (WebGL利用不可?): ' + e.message;
      console.error('Error initializing PIXI.Application:', e);
      throw e; // 初期化失敗時はここで処理を中断
  }

  // Renderer初期化チェック (app.initが成功すればrendererは存在するはず)
  if (!app.renderer) {
    STAGE_ELEMENT.textContent = 'Pixi Renderer の初期化に失敗しました。';
    console.error('Pixi Renderer initialization failed after app.init. PIXI object:', PIXI, 'App object:', app);
    throw new Error('Renderer init failed after app.init');
  }

  // DOMにCanvasを追加 (v8では app.canvas を使用)
  STAGE_ELEMENT.appendChild(app.canvas);


  // PIXI Graphicsオブジェクトをステージに追加
  app.stage.addChild(gEdges);
  app.stage.addChild(gNodes);
  app.stage.addChild(gTestBounds); // テスト図形も追加

  cacheCssColors(); // CSS カラーをキャッシュ

  window.addEventListener('resize', resizeSquare);
  resizeSquare(); // 初期リサイズ実行

  // 入力イベントリスナーを設定 (v8 style)
  app.stage.eventMode = 'static';
  app.stage.interactive = true; // 互換性のため残しても良いが、eventModeが主
  app.stage.on('pointerdown', onPointerDown);
  app.stage.on('pointermove', onPointerMove);

  // JSONデータ読み込み
  fetch('contents.json')
    .then(response => {
      if (!response.ok) {
        throw new Error(`HTTP error! status: ${response.status} while fetching contents.json`);
      }
      return response.json();
    })
    .then(data => {
      puzzles = data.puzzles;
      if (puzzles && puzzles.length > 0) {
        loadPuzzle(1); // 最初のレベルをロード
        // drawTestBounds();
      } else {
        console.error("No puzzles found in contents.json or data is malformed.");
        STAGE_ELEMENT.textContent = 'パズルデータの読み込みに失敗しました。contents.jsonを確認してください。';
      }
    })
    .catch(error => {
      console.error('Failed to load or process contents.json:', error);
      STAGE_ELEMENT.textContent = `エラー: ${error.message}`;
    });

  // UIボタンのイベントリスナー
  document.getElementById('resetBtn').onclick = () => {
    if (currentPuzzle) {
      loadPuzzle(currentPuzzle.difficulty);
    }
  };

  document.getElementById('hintBtn').onclick = () => {
    if (!currentPuzzle) return;
    const unsolvedEdgeIndex = currentPuzzle.edges.findIndex((_, i) => !tracedEdges.has(i));
    if(unsolvedEdgeIndex === -1) return;

    const hintEdge = currentPuzzle.edges[unsolvedEdgeIndex];
    currentPath = [hintEdge.from];
    tracedEdges.clear();
    draw();
  };

  // Optional: Start the Pixi ticker if autoStart was false in app.init options
  // app.ticker.start();
}

// ゲーム初期化を実行
initializeGame().catch(error => {
    // initializeGame内でスローされた致命的なエラーをここでキャッチ
    console.error("ゲームの初期化中に致命的なエラーが発生しました:", error);
    // 必要であれば、ユーザーにエラーを通知する処理をここに追加
});

</script>
</body>
</html>
