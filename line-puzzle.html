<!doctype html>
<html lang="ja">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width,initial-scale=1">
<title>Line Puzzle Pro WebGL</title>
<link href="https://fonts.googleapis.com/css2?family=Inter:wght@500;700&display=swap" rel="stylesheet">
<script src="pixi.min.js"></script>
<script src="pixi.js"></script>
<style>
:root{
  --bg:#f4f7fb;
  --node:#43a4ff;
  --edge:#7b93ad;
  --edge-on:#43a4ff;
  --accent:#ffbf3c;
  --radius:14px;
  font-family:"Inter",system-ui,sans-serif;
}
html,body{margin:0;height:100%;display:flex;flex-direction:column;font-family:sans-serif}
#stage{flex:1;display:flex;justify-content:center;align-items:center;overflow:hidden;background:#f4f7fb}
canvas{touch-action:none}
#wrap{display:flex;flex-direction:column;height:100%}
header{display:flex;justify-content:center;align-items:center;height:56px;
  backdrop-filter:blur(8px);background:rgba(255,255,255,.8);box-shadow:0 4px 12px rgba(0,0,0,.1)}
h1{margin:0;font-size:1rem;font-weight:700}
#ui{display:flex;gap:.6rem;padding:10px;background:rgba(255,255,255,.8);backdrop-filter:blur(8px)}
#ui button{flex:1;border:none;padding:12px 0;border-radius:var(--radius);font-weight:700;
  background:#fff;box-shadow:0 4px 8px rgba(0,0,0,.1);cursor:pointer}
#ui button:active{transform:scale(.96)}
</style>
</head>
<body>
<div id="wrap">
  <header><h1>Line Puzzle Pro</h1></header>
  <div id="stage"></div>
  <div id="ui">
    <button id="resetBtn">Reset</button>
    <button id="hintBtn">Hint</button>
  </div>
</div>

<script>
// グローバル変数の宣言
const STAGE_ELEMENT = document.getElementById('stage');
let puzzles = [];
let currentPuzzle = null;
const tracedEdges = new Set();
let currentPath = [];

// PIXI Graphics Objects
const gEdges = new PIXI.Graphics();
const gNodes = new PIXI.Graphics();
const gTestBounds = new PIXI.Graphics(); // 元の 'g' (テスト図形)

// 定数
const NODE_BASE_RADIUS = 20; // ノードの基本半径 (ピクセル単位)
const NODE_HIT_RADIUS_SCALE_FACTOR = 1.2; // ノードの当たり判定半径のスケール係数
const BASE_CANVAS_WIDTH_FOR_SCALING = 800; // ノードサイズスケーリングの基準となるキャンバス幅

// CSSカラーのキャッシュ用オブジェクト
let appColors = {
    edge: 0x7b93ad,
    edgeOn: 0x43a4ff,
    node: 0x43a4ff,
    accent: 0xffbf3c,
};

// Pixi Application 初期化
const app = new PIXI.Application({
  width: 1, // 初期サイズはリサイズ時に調整
  height: 1,
  backgroundAlpha: 0, // HTMLの背景を透過
  antialias: true,
  // preferEnvironment: 'auto' // デフォルトでauto。明示も可
});

// Renderer初期化チェック
if (!app.renderer) {
  STAGE_ELEMENT.textContent = 'Pixi Renderer の初期化に失敗しました。お使いのブラウザがWebGLまたはCanvas 2Dをサポートしているか、またはPixiJSライブラリが正しく読み込まれているか確認してください。';
  console.error('Pixi Renderer initialization failed. PIXI object:', PIXI);
  throw new Error('Renderer init failed');
}

// PixiJSのバージョンに応じて app.canvas または app.view を使用
// v8以降は app.canvas, v7以前は app.view
// ここでは、元のコードのコメントに基づき v8以降を想定し app.canvas を使用
STAGE_ELEMENT.appendChild(app.canvas || app.view);


// CSSから色を読み込んでキャッシュする関数
function cacheCssColors() {
  const styles = getComputedStyle(document.documentElement);
  appColors.edge = PIXI.utils.string2hex(styles.getPropertyValue('--edge'));
  appColors.edgeOn = PIXI.utils.string2hex(styles.getPropertyValue('--edge-on'));
  appColors.node = PIXI.utils.string2hex(styles.getPropertyValue('--node'));
  appColors.accent = PIXI.utils.string2hex(styles.getPropertyValue('--accent'));
}

/* ========== 正方形リサイズ ========== */
function resizeSquare() {
  const s = Math.max(1, Math.min(STAGE_ELEMENT.clientWidth, STAGE_ELEMENT.clientHeight));
  app.renderer.resize(s, s);
  // リサイズ後に再描画
  if (currentPuzzle) {
    draw();
  }
}

/* ------------ 描画 ------------ */
function draw(){
  if(!currentPuzzle) return;

  const W = app.renderer.width;
  const H = app.renderer.height; // 正方形なのでWと同じはず
  const nodeRadius = NODE_BASE_RADIUS * (W / BASE_CANVAS_WIDTH_FOR_SCALING);

  gEdges.clear();
  gNodes.clear();

  /* edges */
  gEdges.lineStyle({width: nodeRadius * 0.55, color: appColors.edge, cap: 'round'});
  currentPuzzle.edges.forEach((edge) => {
    const nodeA = currentPuzzle.nodes[edge.from];
    const nodeB = currentPuzzle.nodes[edge.to];
    gEdges.moveTo(nodeA.x * W, nodeA.y * H).lineTo(nodeB.x * W, nodeB.y * H);
  });

  /* traced highlight 上書き */
  gEdges.lineStyle({width: nodeRadius * 0.7, color: appColors.edgeOn, cap: 'round'});
  tracedEdges.forEach(edgeIndex => {
    const edge = currentPuzzle.edges[edgeIndex];
    const nodeA = currentPuzzle.nodes[edge.from];
    const nodeB = currentPuzzle.nodes[edge.to];
    gEdges.moveTo(nodeA.x * W, nodeA.y * H).lineTo(nodeB.x * W, nodeB.y * H);
  });

  /* nodes */
  currentPuzzle.nodes.forEach((n, idx) => {
    const color = (currentPath.length > 0 && currentPath[currentPath.length - 1] === idx) ? appColors.accent : appColors.node;
    gNodes.beginFill(color).drawCircle(n.x * W, n.y * H, nodeRadius).endFill();
  });
}

/* ========== テスト図形 (青枠) ========== */
function drawTestBounds() {
  gTestBounds.clear();
  gTestBounds.lineStyle({ width: 6, color: 0x3498db, cap: 'round' })
   .drawPolygon([20,20 , app.renderer.width-20,20 , app.renderer.width-20,app.renderer.height-20 , 20,app.renderer.height-20 , 20,20]);
}


/* ------------ ロード & リセット ------------ */
function loadPuzzle(level){
  const puzzleData = puzzles.find(p => p.difficulty == level);
  if (!puzzleData) {
    console.error(`Puzzle for level ${level} not found.`);
    return;
  }
  currentPuzzle = puzzleData;
  tracedEdges.clear();
  currentPath.length = 0;
  draw();
}

/* ------------ 入力 (pointer) イベントハンドラ ------------ */
function getTouchedNodeIndex(pointerX, pointerY){
  if (!currentPuzzle) return -1;
  const W = app.renderer.width;
  const H = app.renderer.height;
  const nodeRadius = NODE_BASE_RADIUS * (W / BASE_CANVAS_WIDTH_FOR_SCALING);
  const hitRadius = nodeRadius * NODE_HIT_RADIUS_SCALE_FACTOR;

  return currentPuzzle.nodes.findIndex(node =>
    Math.hypot(node.x * W - pointerX, node.y * H - pointerY) <= hitRadius
  );
}

function getEdgeIndex(nodeAIndex, nodeBIndex){
  if (!currentPuzzle) return -1;
  return currentPuzzle.edges.findIndex(edge =>
    (edge.from === nodeAIndex && edge.to === nodeBIndex) ||
    (edge.from === nodeBIndex && edge.to === nodeAIndex)
  );
}

function connectNodes(nodeAIndex, nodeBIndex){
  const edgeIndex = getEdgeIndex(nodeAIndex, nodeBIndex);
  if(edgeIndex === -1 || tracedEdges.has(edgeIndex)) return false;

  tracedEdges.add(edgeIndex);
  currentPath.push(nodeBIndex);
  draw();
  return true;
}

function onPointerDown(event){
  if (!currentPuzzle) return;
  const localPos = event.data.getLocalPosition(app.stage);
  const touchedNodeIdx = getTouchedNodeIndex(localPos.x, localPos.y);

  if(touchedNodeIdx !== -1){
    currentPath = [touchedNodeIdx]; // パスをリセットして開始
    tracedEdges.clear(); // 既存のトレースもリセット（ゲームの仕様による）
    draw();
  }
}

function onPointerMove(event){
  if (!currentPuzzle || currentPath.length === 0) return; // パスが開始されていなければ何もしない

  const localPos = event.data.getLocalPosition(app.stage);
  const touchedNodeIdx = getTouchedNodeIndex(localPos.x, localPos.y);
  const lastNodeInPath = currentPath[currentPath.length - 1];

  if(touchedNodeIdx !== -1 && touchedNodeIdx !== lastNodeInPath) {
    connectNodes(lastNodeInPath, touchedNodeIdx);
  }
}

// 初期化処理
function initializeGame() {
  // PIXI Graphicsオブジェクトをステージに追加
  app.stage.addChild(gEdges);
  app.stage.addChild(gNodes);
  app.stage.addChild(gTestBounds); // テスト図形も追加

  cacheCssColors(); // CSS カラーをキャッシュ

  window.addEventListener('resize', resizeSquare);
  resizeSquare(); // 初期リサイズ実行

  // 入力イベントリスナーを設定
  app.stage.eventMode = 'static'; // PixiJS v7+
  app.stage.interactive = true; // 古いバージョンや互換性のため
  app.stage.on('pointerdown', onPointerDown);
  app.stage.on('pointermove', onPointerMove);
  // Pointerup でパスをクリアするなどのロジックが必要な場合、ここに追加
  // app.stage.on('pointerup', onPointerUp);
  // app.stage.on('pointerupoutside', onPointerUp);

  // JSONデータ読み込み
  fetch('contents.json')
    .then(response => {
      if (!response.ok) {
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      return response.json();
    })
    .then(data => {
      puzzles = data.puzzles;
      if (puzzles && puzzles.length > 0) {
        loadPuzzle(1); // 最初のレベルをロード
        // drawTestBounds(); // テスト境界線を描画
      } else {
        console.error("No puzzles found in contents.json or data is malformed.");
        STAGE_ELEMENT.textContent = 'パズルデータの読み込みに失敗しました。';
      }
    })
    .catch(error => {
      console.error('Failed to load contents.json:', error);
      STAGE_ELEMENT.textContent = `エラー: ${error.message}`;
    });

  // UIボタンのイベントリスナー
  document.getElementById('resetBtn').onclick = () => {
    if (currentPuzzle) {
      loadPuzzle(currentPuzzle.difficulty);
    }
  };

  document.getElementById('hintBtn').onclick = () => {
    if (!currentPuzzle) return;
    // まだトレースされていないエッジを一つ見つける
    const unsolvedEdgeIndex = currentPuzzle.edges.findIndex((edge, i) => !tracedEdges.has(i));

    if(unsolvedEdgeIndex === -1) return; // 全て解決済み

    const hintEdge = currentPuzzle.edges[unsolvedEdgeIndex];
    // ヒントとして、そのエッジの始点をパスの開始点とする
    // (より高度なヒントロジックも可能)
    currentPath = [hintEdge.from];
    tracedEdges.clear(); // ヒント開始時に既存トレースをクリアするかは仕様による
    // tracedEdges.add(unsolvedEdgeIndex); // ヒントで示したエッジをトレース済みにする場合
    draw();
  };
}

// ゲーム初期化を実行
initializeGame();

</script>
</body>
</html>
