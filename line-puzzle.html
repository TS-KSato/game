<!doctype html>
<html lang="ja">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Line Puzzle</title>
<script src="pixi.js"></script>
<style>
html,body{margin:0;height:100%;display:flex;flex-direction:column;background:#f4f7fb;font-family:sans-serif}
header{height:56px;display:flex;justify-content:center;align-items:center;
       background:rgba(255,255,255,.8);backdrop-filter:blur(8px);box-shadow:0 4px 12px rgba(0,0,0,.12)}
h1{margin:0;font-size:1rem;font-weight:700}
#stage{flex:1;display:flex;justify-content:center;align-items:center;overflow:hidden}
#ui{display:flex;gap:.6rem;padding:10px;background:rgba(255,255,255,.8);backdrop-filter:blur(8px)}
#ui button{flex:1;border:none;padding:12px 0;border-radius:14px;background:#fff;font-weight:700;box-shadow:0 4px 8px rgba(0,0,0,.1);cursor:pointer}
#ui button:active{transform:scale(.96)}
canvas{touch-action:none}
</style>
</head>
<body>

<header><h1>Line Puzzle Pro</h1></header>
<div id="stage"></div>
<div id="ui">
  <button id="resetBtn">Reset</button>
  <button id="hintBtn">Hint</button>
</div>

<script>
/* ===== DOM が組み上がってから実行 ===== */
document.addEventListener('DOMContentLoaded', async () => {
  const STAGE = document.getElementById('stage');

  /* --- 1. Pixi Application を同期生成し、ここで init() を await --- */
  const app = new PIXI.Application();
  await app.init({
    width: 1,
    height: 1,
    backgroundAlpha: 0,
    antialias: true,
    preferEnvironment: 'auto'   // WebGL ⇒ Canvas2D 自動フォールバック
  });

  /* --- 2. renderer が確実に存在するので view(canvas) を DOM へ --- */
  STAGE.appendChild(app.canvas);

  /* --- 3. 正方形フィット --- */
  function resizeSquare(){
    const size = Math.max(1, Math.min(STAGE.clientWidth, STAGE.clientHeight));
    app.renderer.resize(size, size);
    redraw();
  }
  window.addEventListener('resize', resizeSquare);
  resizeSquare();

  /* ---------- Graphics レイヤ ---------- */
  const gEdges = new PIXI.Graphics();
  const gNodes = new PIXI.Graphics();
  app.stage.addChild(gEdges, gNodes);

  /* ---------- パズル読み込み ---------- */
  let puzzles=[], cur=null, traced=new Set(), path=[];
  fetch('contents.json')
    .then(r=>r.json())
    .then(data=>{puzzles=data.puzzles; loadLevel(1);});

  function loadLevel(level){
    cur = puzzles.find(p=>p.difficulty == level);
    traced.clear(); path.length = 0;
    redraw();
  }

  /* ---------- 描画 ---------- */
  const R_BASE = 22;
  function redraw(){
    if(!cur) return;
    const W = app.renderer.width,
          H = app.renderer.height,
          r = R_BASE * (W / 800);      // 基準800pxからスケール

    gEdges.clear(); gNodes.clear();

    // 全エッジ (未トレース)
    gEdges.lineStyle({width:r*0.55, color:0x7b93ad, cap:'round'});
    cur.edges.forEach(e=>{
      const a=cur.nodes[e.from], b=cur.nodes[e.to];
      gEdges.moveTo(a.x*W, a.y*H).lineTo(b.x*W, b.y*H);
    });

    // トレース済みエッジ
    gEdges.lineStyle({width:r*0.7, color:0x43a4ff, cap:'round'});
    traced.forEach(i=>{
      const e=cur.edges[i], a=cur.nodes[e.from], b=cur.nodes[e.to];
      gEdges.moveTo(a.x*W, a.y*H).lineTo(b.x*W, b.y*H);
    });

    // ノード
    cur.nodes.forEach((n,i)=>{
      const col = (path[path.length-1]===i)?0xffbf3c:0x43a4ff;
      gNodes.beginFill(col).drawCircle(n.x*W, n.y*H, r).endFill();
    });
  }

  /* ---------- 当たり判定 ---------- */
  function nodeAt(px,py){
    const W=app.renderer.width,H=app.renderer.height;
    const r=R_BASE * 1.2 * (W/800);
    return cur.nodes.findIndex(n=>Math.hypot(n.x*W-px,n.y*H-py)<=r);
  }
  function edgeIdx(a,b){
    return cur.edges.findIndex(e=>(e.from===a&&e.to===b)||(e.from===b&&e.to===a));
  }

  /* ---------- ポインタイベント ---------- */
  app.stage.eventMode='static';
  app.stage.on('pointerdown',e=>{
    const {x,y}=e.global, idx=nodeAt(x,y);
    if(idx!==-1){ path=[idx]; redraw(); }
  });
  app.stage.on('pointermove',e=>{
    if(!path.length) return;
    const {x,y}=e.global, idx=nodeAt(x,y);
    if(idx!==-1 && idx!==path[path.length-1]){
      const id=edgeIdx(path[path.length-1], idx);
      if(id!==-1 && !traced.has(id)){
        traced.add(id); path.push(idx); redraw();
      }
    }
  });

  /* ---------- UIボタン ---------- */
  document.getElementById('resetBtn').onclick=()=>{ traced.clear(); path.length=0; redraw(); };
  document.getElementById('hintBtn').onclick=()=>{
    const id=cur.edges.findIndex((_,i)=>!traced.has(i));
    if(id===-1) return;
    path=[cur.edges[id].from]; redraw();
  };
});
</script>
</body>
</html>
